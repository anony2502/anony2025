[
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2024-07-24 22:09:04+02:00",
    "commit_src": "28574b5fe5e7ad42831d2b345e5f5504bf3ea10c",
    "commit_tgt": "9505a8fafcf8d3ff673ac08d084bc889641f96d9",
    "changed_test": "src/test/java/org/prebid/server/auction/SkippedAuctionServiceTest.java#skipAuctionShouldReturnFailedFutureWhenRequestIsRejected",
    "changed_prod": "src/main/java/org/prebid/server/auction/SkippedAuctionService.java#skipAuction",
    "test_code_src": "    @Test\n    public void skipAuctionShouldReturnFailedFutureWhenRequestIsRejected() {\n        // given\n        final AuctionContext givenAuctionContext = AuctionContext.builder()\n                .requestRejected(true)\n                .build();\n\n        // when\n        final Future<AuctionContext> result = target.skipAuction(givenAuctionContext);\n\n        // then\n        assertThat(result.succeeded()).isTrue();\n        final BidResponse expectedBidResponse = BidResponse.builder().seatbid(emptyList()).build();\n        assertThat(result.result()).isEqualTo(givenAuctionContext.with(expectedBidResponse));\n\n        verifyNoInteractions(storedResponseProcessor, bidResponseCreator);\n    }",
    "test_code_tgt": "    @Test\n    public void skipAuctionShouldReturnFailedFutureWhenRequestIsRejected() {\n        // given\n        final AuctionContext givenAuctionContext = AuctionContext.builder()\n                .requestRejected(true)\n                .build();\n\n        // when\n        final Future<AuctionContext> result = target.skipAuction(givenAuctionContext);\n\n        // then\n        assertThat(result.failed()).isTrue();\n        assertThat(result.cause()).hasMessage(\"Rejected request cannot be skipped\");\n        verifyNoInteractions(storedResponseProcessor, bidResponseCreator);\n    }",
    "prod_code_src": "    public Future<AuctionContext> skipAuction(AuctionContext auctionContext) {\n        if (auctionContext.isRequestRejected()) {\n            return Future.succeededFuture(auctionContext.with(\n                    BidResponse.builder().seatbid(Collections.emptyList()).build()));\n        }\n\n        final ExtStoredAuctionResponse storedResponse = Optional.ofNullable(auctionContext.getBidRequest())\n                .map(BidRequest::getExt)\n                .map(ExtRequest::getPrebid)\n                .map(ExtRequestPrebid::getStoredAuctionResponse)\n                .orElse(null);\n\n        if (storedResponse == null) {\n            return Future.failedFuture(new InvalidRequestException(\n                    \"the auction can not be skipped, ext.prebid.storedauctionresponse is absent\"));\n        }\n\n        final List<SeatBid> seatBids = storedResponse.getSeatBids();\n        if (seatBids != null) {\n            return validateStoredSeatBid(seatBids)\n                    .recover(throwable -> {\n                        auctionContext.getDebugWarnings().add(throwable.getMessage());\n                        return Future.succeededFuture(Collections.emptyList());\n                    })\n                    .compose(storedSeatBids -> enrichAuctionContextWithBidResponse(auctionContext, storedSeatBids))\n                    .map(AuctionContext::skipAuction);\n        }\n\n        if (storedResponse.getId() != null) {\n            final Timeout timeout = auctionContext.getTimeoutContext().getTimeout();\n            return storedResponseProcessor.getStoredResponseResult(storedResponse.getId(), timeout)\n                    .map(StoredResponseResult::getAuctionStoredResponse)\n                    .recover(throwable -> {\n                        auctionContext.getDebugWarnings().add(throwable.getMessage());\n                        return Future.succeededFuture(Collections.emptyList());\n                    })\n                    .compose(storedSeatBids -> enrichAuctionContextWithBidResponse(auctionContext, storedSeatBids))\n                    .map(AuctionContext::skipAuction);\n        }\n\n        return Future.failedFuture(new InvalidRequestException(\n                \"the auction can not be skipped, ext.prebid.storedauctionresponse can not be resolved properly\"));\n\n    }",
    "prod_code_tgt": "    public Future<AuctionContext> skipAuction(AuctionContext auctionContext) {\n        if (auctionContext.isRequestRejected()) {\n            return Future.failedFuture(\"Rejected request cannot be skipped\");\n        }\n\n        final ExtStoredAuctionResponse storedResponse = Optional.ofNullable(auctionContext.getBidRequest())\n                .map(BidRequest::getExt)\n                .map(ExtRequest::getPrebid)\n                .map(ExtRequestPrebid::getStoredAuctionResponse)\n                .orElse(null);\n\n        if (storedResponse == null) {\n            return Future.failedFuture(new InvalidRequestException(\n                    \"the auction can not be skipped, ext.prebid.storedauctionresponse is absent\"));\n        }\n\n        final List<SeatBid> seatBids = storedResponse.getSeatBids();\n        if (seatBids != null) {\n            return validateStoredSeatBid(seatBids)\n                    .recover(throwable -> {\n                        auctionContext.getDebugWarnings().add(throwable.getMessage());\n                        return Future.succeededFuture(Collections.emptyList());\n                    })\n                    .compose(storedSeatBids -> enrichAuctionContextWithBidResponse(auctionContext, storedSeatBids))\n                    .map(AuctionContext::skipAuction);\n        }\n\n        if (storedResponse.getId() != null) {\n            final Timeout timeout = auctionContext.getTimeoutContext().getTimeout();\n            return storedResponseProcessor.getStoredResponseResult(storedResponse.getId(), timeout)\n                    .map(StoredResponseResult::getAuctionStoredResponse)\n                    .recover(throwable -> {\n                        auctionContext.getDebugWarnings().add(throwable.getMessage());\n                        return Future.succeededFuture(Collections.emptyList());\n                    })\n                    .compose(storedSeatBids -> enrichAuctionContextWithBidResponse(auctionContext, storedSeatBids))\n                    .map(AuctionContext::skipAuction);\n        }\n\n        return Future.failedFuture(new InvalidRequestException(\n                \"the auction can not be skipped, ext.prebid.storedauctionresponse can not be resolved properly\"));\n\n    }",
    "test_id": 0,
    "src_java_version": "21",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "21",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2024-05-29 13:52:00+02:00",
    "commit_src": "e02e0942f056307d2b502cf5dd2c899e61257aba",
    "commit_tgt": "edd4dd17c170d14b57835bd86b8215e25e391bda",
    "changed_test": "src/test/java/org/prebid/server/bidder/ucfunnel/UcfunnelBidderTest.java#makeHttpRequestsShouldCreateCorrectURL",
    "changed_prod": "src/main/java/org/prebid/server/bidder/ucfunnel/UcfunnelBidder.java#makeHttpRequests",
    "test_code_src": "    @Test\n    public void makeHttpRequestsShouldCreateCorrectURL() {\n        // given\n        final BidRequest bidRequest = BidRequest.builder()\n                .imp(singletonList(Imp.builder()\n                        .id(\"123\")\n                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n                                ExtImpUcfunnel.of(\"adUnitId\", \"partnerId\")))).build()))\n                .build();\n\n        // when\n        final Result<List<HttpRequest<BidRequest>>> result = target.makeHttpRequests(bidRequest);\n\n        // then\n        assertThat(result.getErrors()).isEmpty();\n        assertThat(result.getValue()).hasSize(1);\n        assertThat(result.getValue().get(0).getUri()).isEqualTo(\"https://test.endpoint.com/partnerId/request\");\n    }",
    "test_code_tgt": "    @Test\n    public void makeHttpRequestsShouldCreateCorrectURL() {\n        // given\n        final BidRequest bidRequest = BidRequest.builder()\n                .imp(singletonList(Imp.builder()\n                        .id(\"123\")\n                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n                                ExtImpUcfunnel.of(\"adUnitId\", \"partnerId\")))).build()))\n                .build();\n\n        // when\n        final Result<List<HttpRequest<BidRequest>>> result = target.makeHttpRequests(bidRequest);\n\n        // then\n        assertThat(result.getErrors()).isEmpty();\n        assertThat(result.getValue()).hasSize(1);\n        assertThat(result.getValue().getFirst().getUri()).isEqualTo(\"https://test.endpoint.com/partnerId/request\");\n    }",
    "prod_code_src": "    @Override\n    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n        final List<BidderError> errors = new ArrayList<>();\n\n        if (CollectionUtils.isEmpty(request.getImp())) {\n            return Result.withError(BidderError.badInput(\"No valid impressions in the bid request\"));\n        }\n\n        String partnerId = null;\n        try {\n            final ExtImpUcfunnel extImpUcfunnel = parseImpExt(request.getImp().get(0));\n            final String adUnitId = extImpUcfunnel.getAdunitid();\n            partnerId = extImpUcfunnel.getPartnerid();\n            if (StringUtils.isEmpty(partnerId) || StringUtils.isEmpty(adUnitId)) {\n                errors.add(BidderError.badInput(\"No PartnerId or AdUnitId in the bid request\"));\n                return Result.withErrors(errors);\n            }\n        } catch (PreBidException e) {\n            errors.add(BidderError.badInput(e.getMessage()));\n        }\n\n        final String requestUrl = \"%s/%s/request\".formatted(endpointUrl, HttpUtil.encodeUrl(partnerId));\n\n        return Result.of(Collections.singletonList(BidderUtil.defaultRequest(request, requestUrl, mapper)),\n                errors);\n    }",
    "prod_code_tgt": "    @Override\n    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n        final List<BidderError> errors = new ArrayList<>();\n\n        if (CollectionUtils.isEmpty(request.getImp())) {\n            return Result.withError(BidderError.badInput(\"No valid impressions in the bid request\"));\n        }\n\n        String partnerId = null;\n        try {\n            final ExtImpUcfunnel extImpUcfunnel = parseImpExt(request.getImp().getFirst());\n            final String adUnitId = extImpUcfunnel.getAdunitid();\n            partnerId = extImpUcfunnel.getPartnerid();\n            if (StringUtils.isEmpty(partnerId) || StringUtils.isEmpty(adUnitId)) {\n                errors.add(BidderError.badInput(\"No PartnerId or AdUnitId in the bid request\"));\n                return Result.withErrors(errors);\n            }\n        } catch (PreBidException e) {\n            errors.add(BidderError.badInput(e.getMessage()));\n        }\n\n        final String requestUrl = \"%s/%s/request\".formatted(endpointUrl, HttpUtil.encodeUrl(partnerId));\n\n        return Result.of(Collections.singletonList(BidderUtil.defaultRequest(request, requestUrl, mapper)),\n                errors);\n    }",
    "test_id": 2,
    "src_java_version": "21",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "21",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2024-05-29 13:52:00+02:00",
    "commit_src": "e02e0942f056307d2b502cf5dd2c899e61257aba",
    "commit_tgt": "edd4dd17c170d14b57835bd86b8215e25e391bda",
    "changed_test": "src/test/java/org/prebid/server/bidder/adpone/AdponeBidderTest.java#makeHttpRequestsShouldReturnErrorIfFirstImpExtCannotBeParsed",
    "changed_prod": "src/main/java/org/prebid/server/bidder/adpone/AdponeBidder.java#makeHttpRequests",
    "test_code_src": "    @Test\n    public void makeHttpRequestsShouldReturnErrorIfFirstImpExtCannotBeParsed() {\n        // given\n        final BidRequest bidRequest = givenBidRequest(mapper.createArrayNode());\n\n        // when\n        final Result<List<HttpRequest<BidRequest>>> result = target.makeHttpRequests(bidRequest);\n\n        // then\n        assertThat(result.getValue()).isEmpty();\n\n        final List<BidderError> errors = result.getErrors();\n        assertThat(errors).hasSize(1);\n        assertThat(errors.get(0).getMessage()).startsWith(\"Cannot deserialize value\");\n    }",
    "test_code_tgt": "    @Test\n    public void makeHttpRequestsShouldReturnErrorIfFirstImpExtCannotBeParsed() {\n        // given\n        final BidRequest bidRequest = givenBidRequest(mapper.createArrayNode());\n\n        // when\n        final Result<List<HttpRequest<BidRequest>>> result = target.makeHttpRequests(bidRequest);\n\n        // then\n        assertThat(result.getValue()).isEmpty();\n\n        final List<BidderError> errors = result.getErrors();\n        assertThat(errors).hasSize(1);\n        assertThat(errors.getFirst().getMessage()).startsWith(\"Cannot deserialize value\");\n    }",
    "prod_code_src": "    @Override\n    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest bidRequest) {\n        try {\n            mapper.mapper().convertValue(bidRequest.getImp().get(0).getExt().get(\"bidder\"), ExtImpAdpone.class);\n        } catch (IllegalArgumentException e) {\n            return Result.withError(BidderError.badInput(e.getMessage()));\n        }\n\n        return Result.of(Collections.singletonList(\n                        HttpRequest.<BidRequest>builder()\n                                .method(HttpMethod.POST)\n                                .uri(endpointUrl)\n                                .headers(HttpUtil.headers()\n                                        .add(HttpUtil.X_OPENRTB_VERSION_HEADER, OPENRTB_VERSION))\n                                .body(mapper.encodeToBytes(bidRequest))\n                                .payload(bidRequest)\n                                .build()),\n                Collections.emptyList());\n    }",
    "prod_code_tgt": "    @Override\n    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest bidRequest) {\n        try {\n            mapper.mapper().convertValue(bidRequest.getImp().getFirst().getExt().get(\"bidder\"), ExtImpAdpone.class);\n        } catch (IllegalArgumentException e) {\n            return Result.withError(BidderError.badInput(e.getMessage()));\n        }\n\n        return Result.of(Collections.singletonList(\n                        HttpRequest.<BidRequest>builder()\n                                .method(HttpMethod.POST)\n                                .uri(endpointUrl)\n                                .headers(HttpUtil.headers()\n                                        .add(HttpUtil.X_OPENRTB_VERSION_HEADER, OPENRTB_VERSION))\n                                .body(mapper.encodeToBytes(bidRequest))\n                                .payload(bidRequest)\n                                .build()),\n                Collections.emptyList());\n    }",
    "test_id": 3,
    "src_java_version": "21",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "21",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2024-05-08 13:37:45+02:00",
    "commit_src": "d5af622b2bdab526e1752a3afe62be24c7c6e45b",
    "commit_tgt": "6aabd8b65a87006b2516e0ce4918b14d82b11ccf",
    "changed_test": "src/test/java/org/prebid/server/activity/infrastructure/privacy/usnat/reader/USNationalGppReaderTest.java#getMspaOptOutOptionModeShouldReturnExpectedResult",
    "changed_prod": "src/main/java/org/prebid/server/activity/infrastructure/privacy/usnat/reader/USNationalGppReader.java#getMspaOptOutOptionMode",
    "test_code_src": "    @Test\n    public void getMspaOptOutOptionModeShouldReturnExpectedResult() {\n        // given\n        given(uspNatV1.getMspaOptOutOptionMode()).willReturn(1);\n\n        // when and then\n        assertThat(gppReader.getMspaOptOutOptionMode()).isEqualTo(1);\n    }",
    "test_code_tgt": "    @Test\n    public void getMspaOptOutOptionModeShouldReturnExpectedResult() {\n        // given\n        given(usNatV1.getMspaOptOutOptionMode()).willReturn(1);\n\n        // when and then\n        assertThat(gppReader.getMspaOptOutOptionMode()).isEqualTo(1);\n    }",
    "prod_code_src": "    @Override\n    public Integer getMspaOptOutOptionMode() {\n        return ObjectUtil.getIfNotNull(consent, UspNatV1::getMspaOptOutOptionMode);\n    }",
    "prod_code_tgt": "    @Override\n    public Integer getMspaOptOutOptionMode() {\n        return ObjectUtil.getIfNotNull(consent, UsNatV1::getMspaOptOutOptionMode);\n    }",
    "test_id": 6,
    "src_java_version": "21",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "21",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2024-05-08 13:37:45+02:00",
    "commit_src": "d5af622b2bdab526e1752a3afe62be24c7c6e45b",
    "commit_tgt": "6aabd8b65a87006b2516e0ce4918b14d82b11ccf",
    "changed_test": "src/test/java/org/prebid/server/activity/infrastructure/privacy/uscustomlogic/reader/USConnecticutGppReaderTest.java#getMspaOptOutOptionModeShouldReturnExpectedResult",
    "changed_prod": "src/main/java/org/prebid/server/activity/infrastructure/privacy/uscustomlogic/reader/USConnecticutGppReader.java#getMspaOptOutOptionMode",
    "test_code_src": "    @Test\n    public void getMspaOptOutOptionModeShouldReturnExpectedResult() {\n        // given\n        given(uspCtV1.getMspaOptOutOptionMode()).willReturn(1);\n\n        // when and then\n        assertThat(gppReader.getMspaOptOutOptionMode()).isEqualTo(1);\n    }",
    "test_code_tgt": "    @Test\n    public void getMspaOptOutOptionModeShouldReturnExpectedResult() {\n        // given\n        given(usCtV1.getMspaOptOutOptionMode()).willReturn(1);\n\n        // when and then\n        assertThat(gppReader.getMspaOptOutOptionMode()).isEqualTo(1);\n    }",
    "prod_code_src": "    @Override\n    public Integer getMspaOptOutOptionMode() {\n        return ObjectUtil.getIfNotNull(consent, UspCtV1::getMspaOptOutOptionMode);\n    }",
    "prod_code_tgt": "    @Override\n    public Integer getMspaOptOutOptionMode() {\n        return ObjectUtil.getIfNotNull(consent, UsCtV1::getMspaOptOutOptionMode);\n    }",
    "test_id": 7,
    "src_java_version": "21",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "21",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2024-02-26 11:46:33+02:00",
    "commit_src": "3ddbe4763435b213042a21bc288fc3ac3262ae9a",
    "commit_tgt": "7cf656a2204e1684baa71fc0bcd2941b5304c3bd",
    "changed_test": "src/test/java/org/prebid/server/auction/PrivacyEnforcementServiceTest.java#contextFromBidRequestShouldReturnTcfContext",
    "changed_prod": "src/main/java/org/prebid/server/auction/PrivacyEnforcementService.java#contextFromBidRequest",
    "test_code_src": "    @Test\n    public void contextFromBidRequestShouldReturnTcfContext() {\n        // given\n        final String referer = \"Referer\";\n        final BidRequest bidRequest = BidRequest.builder()\n                .regs(Regs.builder().gdpr(1).usPrivacy(\"1YYY\").build())\n                .user(User.builder()\n                        .consent(\"consent\")\n                        .build())\n                .site(Site.builder().ref(referer).build())\n                .build();\n\n        final TcfContext tcfContext = TcfContext.builder()\n                .inGdprScope(true)\n                .consentString(\"consent\")\n                .consent(TCStringEmpty.create())\n                .warnings(emptyList())\n                .build();\n        given(tcfDefinerService.resolveTcfContext(any(), any(), any(), any(), any(), any(), any()))\n                .willReturn(Future.succeededFuture(tcfContext));\n\n        final String accountId = \"account\";\n        final MetricName requestType = MetricName.openrtb2web;\n\n        final AuctionContext auctionContext = AuctionContext.builder()\n                .bidRequest(bidRequest)\n                .account(Account.empty(accountId))\n                .requestTypeMetric(requestType)\n                .prebidErrors(new ArrayList<>())\n                .debugWarnings(new ArrayList<>())\n                .build();\n\n        // when\n        final Future<PrivacyContext> privacyContext = privacyEnforcementService.contextFromBidRequest(auctionContext);\n\n        // then\n        final Privacy privacy = Privacy.builder()\n                .gdpr(\"1\")\n                .consentString(\"consent\")\n                .ccpa(Ccpa.of(\"1YYY\"))\n                .coppa(0)\n                .gpp(EMPTY)\n                .gppSid(emptyList())\n                .build();\n        FutureAssertion.assertThat(privacyContext).succeededWith(PrivacyContext.of(privacy, tcfContext));\n\n        final RequestLogInfo expectedRequestLogInfo = RequestLogInfo.of(requestType, referer, accountId);\n        verify(tcfDefinerService).resolveTcfContext(\n                eq(privacy), isNull(), isNull(), isNull(), same(requestType),\n                eq(expectedRequestLogInfo), isNull());\n    }",
    "test_code_tgt": "    @Test\n    public void contextFromBidRequestShouldReturnTcfContext() {\n        // given\n        final String referer = \"Referer\";\n        final BidRequest bidRequest = BidRequest.builder()\n                .regs(Regs.builder().gdpr(1).usPrivacy(\"1YYY\").build())\n                .user(User.builder()\n                        .consent(\"consent\")\n                        .build())\n                .site(Site.builder().ref(referer).build())\n                .build();\n\n        final TcfContext tcfContext = TcfContext.builder()\n                .inGdprScope(true)\n                .consentString(\"consent\")\n                .consent(TCStringEmpty.create())\n                .warnings(emptyList())\n                .build();\n        given(tcfDefinerService.resolveTcfContext(any(), any(), any(), any(), any(), any(), any()))\n                .willReturn(Future.succeededFuture(tcfContext));\n\n        final String accountId = \"account\";\n        final MetricName requestType = MetricName.openrtb2web;\n\n        final AuctionContext auctionContext = AuctionContext.builder()\n                .bidRequest(bidRequest)\n                .account(Account.empty(accountId))\n                .requestTypeMetric(requestType)\n                .timeoutContext(TimeoutContext.of(0, null, 0))\n                .prebidErrors(new ArrayList<>())\n                .debugWarnings(new ArrayList<>())\n                .build();\n\n        // when\n        final Future<PrivacyContext> privacyContext = privacyEnforcementService.contextFromBidRequest(auctionContext);\n\n        // then\n        final Privacy privacy = Privacy.builder()\n                .gdpr(\"1\")\n                .consentString(\"consent\")\n                .ccpa(Ccpa.of(\"1YYY\"))\n                .coppa(0)\n                .gpp(EMPTY)\n                .gppSid(emptyList())\n                .build();\n        FutureAssertion.assertThat(privacyContext).succeededWith(PrivacyContext.of(privacy, tcfContext));\n\n        final RequestLogInfo expectedRequestLogInfo = RequestLogInfo.of(requestType, referer, accountId);\n        verify(tcfDefinerService).resolveTcfContext(\n                eq(privacy), isNull(), isNull(), isNull(), same(requestType),\n                eq(expectedRequestLogInfo), isNull());\n    }",
    "prod_code_src": "    public Future<PrivacyContext> contextFromBidRequest(AuctionContext auctionContext) {\n        final BidRequest bidRequest = auctionContext.getBidRequest();\n        final List<String> errors = auctionContext.getPrebidErrors();\n        final Account account = auctionContext.getAccount();\n        final MetricName requestType = auctionContext.getRequestTypeMetric();\n        final Timeout timeout = auctionContext.getTimeout();\n\n        final Privacy privacy = privacyExtractor.validPrivacyFrom(bidRequest, errors);\n\n        final Device device = bidRequest.getDevice();\n        final String alpha2CountryCode = resolveAlpha2CountryCode(device);\n        final String effectiveIpAddress = resolveIpAddress(device, privacy);\n\n        final AccountGdprConfig accountGdpr = accountGdprConfig(account);\n        final String accountId = account.getId();\n        final RequestLogInfo requestLogInfo = requestLogInfo(requestType, bidRequest, accountId);\n\n        return tcfDefinerService.resolveTcfContext(\n                        privacy,\n                        alpha2CountryCode,\n                        effectiveIpAddress,\n                        accountGdpr,\n                        requestType,\n                        requestLogInfo,\n                        timeout)\n                .map(tcfContext -> logWarnings(auctionContext.getDebugWarnings(), tcfContext))\n                .map(tcfContext -> PrivacyContext.of(privacy, tcfContext, tcfContext.getIpAddress()));\n    }",
    "prod_code_tgt": "    public Future<PrivacyContext> contextFromBidRequest(AuctionContext auctionContext) {\n        final BidRequest bidRequest = auctionContext.getBidRequest();\n        final List<String> errors = auctionContext.getPrebidErrors();\n        final Account account = auctionContext.getAccount();\n        final MetricName requestType = auctionContext.getRequestTypeMetric();\n        final Timeout timeout = auctionContext.getTimeoutContext().getTimeout();\n\n        final Privacy privacy = privacyExtractor.validPrivacyFrom(bidRequest, errors);\n\n        final Device device = bidRequest.getDevice();\n        final String alpha2CountryCode = resolveAlpha2CountryCode(device);\n        final String effectiveIpAddress = resolveIpAddress(device, privacy);\n\n        final AccountGdprConfig accountGdpr = accountGdprConfig(account);\n        final String accountId = account.getId();\n        final RequestLogInfo requestLogInfo = requestLogInfo(requestType, bidRequest, accountId);\n\n        return tcfDefinerService.resolveTcfContext(\n                        privacy,\n                        alpha2CountryCode,\n                        effectiveIpAddress,\n                        accountGdpr,\n                        requestType,\n                        requestLogInfo,\n                        timeout)\n                .map(tcfContext -> logWarnings(auctionContext.getDebugWarnings(), tcfContext))\n                .map(tcfContext -> PrivacyContext.of(privacy, tcfContext, tcfContext.getIpAddress()));\n    }",
    "test_id": 8,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2024-02-26 11:46:33+02:00",
    "commit_src": "3ddbe4763435b213042a21bc288fc3ac3262ae9a",
    "commit_tgt": "7cf656a2204e1684baa71fc0bcd2941b5304c3bd",
    "changed_test": "src/test/java/org/prebid/server/auction/PrivacyEnforcementServiceTest.java#contextFromBidRequestShouldCallResolveTcfContextWithIpv6AnonymizedWhenIpNotPresentAndLmtIsOne",
    "changed_prod": "src/main/java/org/prebid/server/auction/PrivacyEnforcementService.java#contextFromBidRequest",
    "test_code_src": "    @Test\n    public void contextFromBidRequestShouldCallResolveTcfContextWithIpv6AnonymizedWhenIpNotPresentAndLmtIsOne() {\n        // given\n        final BidRequest bidRequest = BidRequest.builder()\n                .device(Device.builder()\n                        .lmt(1)\n                        .ipv6(\"ipv6\")\n                        .build())\n                .build();\n        given(ipAddressHelper.anonymizeIpv6(any())).willReturn(\"ip-masked\");\n        given(tcfDefinerService.resolveTcfContext(any(), any(), any(), any(), any(), any(), any()))\n                .willReturn(Future.succeededFuture(TcfContext.builder().build()));\n        final AuctionContext auctionContext = AuctionContext.builder()\n                .bidRequest(bidRequest)\n                .account(Account.empty(\"account\"))\n                .prebidErrors(new ArrayList<>())\n                .build();\n\n        // when\n        privacyEnforcementService.contextFromBidRequest(auctionContext);\n\n        // then\n        verify(tcfDefinerService).resolveTcfContext(any(), any(), eq(\"ip-masked\"), any(), any(), any(), any());\n    }",
    "test_code_tgt": "    @Test\n    public void contextFromBidRequestShouldCallResolveTcfContextWithIpv6AnonymizedWhenIpNotPresentAndLmtIsOne() {\n        // given\n        final BidRequest bidRequest = BidRequest.builder()\n                .device(Device.builder()\n                        .lmt(1)\n                        .ipv6(\"ipv6\")\n                        .build())\n                .build();\n        given(ipAddressHelper.anonymizeIpv6(any())).willReturn(\"ip-masked\");\n        given(tcfDefinerService.resolveTcfContext(any(), any(), any(), any(), any(), any(), any()))\n                .willReturn(Future.succeededFuture(TcfContext.builder().build()));\n        final AuctionContext auctionContext = AuctionContext.builder()\n                .bidRequest(bidRequest)\n                .account(Account.empty(\"account\"))\n                .timeoutContext(TimeoutContext.of(0, null, 0))\n                .prebidErrors(new ArrayList<>())\n                .build();\n\n        // when\n        privacyEnforcementService.contextFromBidRequest(auctionContext);\n\n        // then\n        verify(tcfDefinerService).resolveTcfContext(any(), any(), eq(\"ip-masked\"), any(), any(), any(), any());\n    }",
    "prod_code_src": "    public Future<PrivacyContext> contextFromBidRequest(AuctionContext auctionContext) {\n        final BidRequest bidRequest = auctionContext.getBidRequest();\n        final List<String> errors = auctionContext.getPrebidErrors();\n        final Account account = auctionContext.getAccount();\n        final MetricName requestType = auctionContext.getRequestTypeMetric();\n        final Timeout timeout = auctionContext.getTimeout();\n\n        final Privacy privacy = privacyExtractor.validPrivacyFrom(bidRequest, errors);\n\n        final Device device = bidRequest.getDevice();\n        final String alpha2CountryCode = resolveAlpha2CountryCode(device);\n        final String effectiveIpAddress = resolveIpAddress(device, privacy);\n\n        final AccountGdprConfig accountGdpr = accountGdprConfig(account);\n        final String accountId = account.getId();\n        final RequestLogInfo requestLogInfo = requestLogInfo(requestType, bidRequest, accountId);\n\n        return tcfDefinerService.resolveTcfContext(\n                        privacy,\n                        alpha2CountryCode,\n                        effectiveIpAddress,\n                        accountGdpr,\n                        requestType,\n                        requestLogInfo,\n                        timeout)\n                .map(tcfContext -> logWarnings(auctionContext.getDebugWarnings(), tcfContext))\n                .map(tcfContext -> PrivacyContext.of(privacy, tcfContext, tcfContext.getIpAddress()));\n    }",
    "prod_code_tgt": "    public Future<PrivacyContext> contextFromBidRequest(AuctionContext auctionContext) {\n        final BidRequest bidRequest = auctionContext.getBidRequest();\n        final List<String> errors = auctionContext.getPrebidErrors();\n        final Account account = auctionContext.getAccount();\n        final MetricName requestType = auctionContext.getRequestTypeMetric();\n        final Timeout timeout = auctionContext.getTimeoutContext().getTimeout();\n\n        final Privacy privacy = privacyExtractor.validPrivacyFrom(bidRequest, errors);\n\n        final Device device = bidRequest.getDevice();\n        final String alpha2CountryCode = resolveAlpha2CountryCode(device);\n        final String effectiveIpAddress = resolveIpAddress(device, privacy);\n\n        final AccountGdprConfig accountGdpr = accountGdprConfig(account);\n        final String accountId = account.getId();\n        final RequestLogInfo requestLogInfo = requestLogInfo(requestType, bidRequest, accountId);\n\n        return tcfDefinerService.resolveTcfContext(\n                        privacy,\n                        alpha2CountryCode,\n                        effectiveIpAddress,\n                        accountGdpr,\n                        requestType,\n                        requestLogInfo,\n                        timeout)\n                .map(tcfContext -> logWarnings(auctionContext.getDebugWarnings(), tcfContext))\n                .map(tcfContext -> PrivacyContext.of(privacy, tcfContext, tcfContext.getIpAddress()));\n    }",
    "test_id": 9,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-12-07 16:20:04+02:00",
    "commit_src": "5108de36ce0d8a51605ad9281e133f4956448105",
    "commit_tgt": "96eda0b11ed826d09b815f3afff562d38766b549",
    "changed_test": "src/test/java/org/prebid/server/auction/TargetingKeywordsCreatorTest.java#shouldIncludeFormatOpenrtb",
    "changed_prod": "src/main/java/org/prebid/server/auction/TargetingKeywordsCreator.java#create",
    "test_code_src": "    @Test\n    public void shouldIncludeFormatOpenrtb() {\n        // given\n        final Bid bid = Bid.builder()\n                .price(BigDecimal.valueOf(3.87)).build();\n\n        // when\n        final Map<String, String> keywords = TargetingKeywordsCreator.create(\n                        ExtPriceGranularity.of(\n                                2,\n                                singletonList(ExtGranularityRange.of(BigDecimal.valueOf(5), BigDecimal.valueOf(0.5)))),\n                        true,\n                        true,\n                        false,\n                        true,\n                        false,\n                        0,\n                        null,\n                        null,\n                        null)\n                .makeFor(bid, \"\", true, null, \"banner\", null, null);\n\n        // then\n        assertThat(keywords).contains(entry(\"hb_format\", \"banner\"));\n    }",
    "test_code_tgt": "    @Test\n    public void shouldIncludeFormatOpenrtb() {\n        // given\n        final Bid bid = Bid.builder()\n                .price(BigDecimal.valueOf(3.87)).build();\n\n        // when\n        final Map<String, String> keywords = TargetingKeywordsCreator.create(\n                        ExtPriceGranularity.of(\n                                2,\n                                singletonList(ExtGranularityRange.of(BigDecimal.valueOf(5), BigDecimal.valueOf(0.5)))),\n                        true,\n                        true,\n                        false,\n                        true,\n                        false,\n                        0,\n                        null,\n                        null,\n                        null,\n                        defaultKeyPrefix)\n                .makeFor(bid, \"\", true, null, \"banner\", null, null);\n\n        // then\n        assertThat(keywords).contains(entry(\"hb_format\", \"banner\"));\n    }",
    "prod_code_src": "    /**\n     * Creates {@link TargetingKeywordsCreator} for the given params.\n     */\n    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n                                                  boolean includeWinners,\n                                                  boolean includeBidderKeys,\n                                                  boolean alwaysIncludeDeals,\n                                                  boolean includeFormat,\n                                                  boolean isApp,\n                                                  int truncateAttrChars,\n                                                  String cacheHost,\n                                                  String cachePath,\n                                                  TargetingKeywordsResolver resolver) {\n\n        return new TargetingKeywordsCreator(\n                PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n                includeWinners,\n                includeBidderKeys,\n                alwaysIncludeDeals,\n                includeFormat,\n                isApp,\n                truncateAttrChars,\n                cacheHost,\n                cachePath,\n                resolver);\n    }",
    "prod_code_tgt": "    /**\n     * Creates {@link TargetingKeywordsCreator} for the given params.\n     */\n    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n                                                  boolean includeWinners,\n                                                  boolean includeBidderKeys,\n                                                  boolean alwaysIncludeDeals,\n                                                  boolean includeFormat,\n                                                  boolean isApp,\n                                                  int truncateAttrChars,\n                                                  String cacheHost,\n                                                  String cachePath,\n                                                  TargetingKeywordsResolver resolver,\n                                                  String keyPrefix) {\n        return new TargetingKeywordsCreator(\n                PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n                includeWinners,\n                includeBidderKeys,\n                alwaysIncludeDeals,\n                includeFormat,\n                isApp,\n                truncateAttrChars,\n                cacheHost,\n                cachePath,\n                resolver,\n                keyPrefix);\n    }",
    "test_id": 12,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-12-07 16:20:04+02:00",
    "commit_src": "5108de36ce0d8a51605ad9281e133f4956448105",
    "commit_tgt": "96eda0b11ed826d09b815f3afff562d38766b549",
    "changed_test": "src/test/java/org/prebid/server/auction/TargetingKeywordsCreatorTest.java#shouldNotTruncateTargetingKeywordsIfTruncateAttrCharsIsNotDefined",
    "changed_prod": "src/main/java/org/prebid/server/auction/TargetingKeywordsCreator.java#create",
    "test_code_src": "    @Test\n    public void shouldNotTruncateTargetingKeywordsIfTruncateAttrCharsIsNotDefined() {\n        // given\n        final Bid bid = Bid.builder().price(BigDecimal.ONE).build();\n\n        // when\n        final Map<String, String> keywords = TargetingKeywordsCreator.create(\n                        ExtPriceGranularity.of(\n                                2,\n                                singletonList(ExtGranularityRange.of(BigDecimal.valueOf(5), BigDecimal.valueOf(0.5)))),\n                        false,\n                        true,\n                        false,\n                        false,\n                        false,\n                        0,\n                        null,\n                        null,\n                        null)\n                .makeFor(bid, \"someVeryLongBidderName\", true, null, null, null, null);\n\n        // then\n        assertThat(keywords).hasSize(2)\n                .containsKeys(\"hb_bidder_someVeryLongBidderName\", \"hb_pb_someVeryLongBidderName\");\n    }",
    "test_code_tgt": "    @Test\n    public void shouldNotTruncateTargetingKeywordsIfTruncateAttrCharsIsNotDefined() {\n        // given\n        final Bid bid = Bid.builder().price(BigDecimal.ONE).build();\n\n        // when\n        final Map<String, String> keywords = TargetingKeywordsCreator.create(\n                        ExtPriceGranularity.of(\n                                2,\n                                singletonList(ExtGranularityRange.of(BigDecimal.valueOf(5), BigDecimal.valueOf(0.5)))),\n                        false,\n                        true,\n                        false,\n                        false,\n                        false,\n                        0,\n                        null,\n                        null,\n                        null,\n                        defaultKeyPrefix)\n                .makeFor(bid, \"someVeryLongBidderName\", true, null, null, null, null);\n\n        // then\n        assertThat(keywords).hasSize(2)\n                .containsKeys(\"hb_bidder_someVeryLongBidderName\", \"hb_pb_someVeryLongBidderName\");\n    }",
    "prod_code_src": "    /**\n     * Creates {@link TargetingKeywordsCreator} for the given params.\n     */\n    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n                                                  boolean includeWinners,\n                                                  boolean includeBidderKeys,\n                                                  boolean alwaysIncludeDeals,\n                                                  boolean includeFormat,\n                                                  boolean isApp,\n                                                  int truncateAttrChars,\n                                                  String cacheHost,\n                                                  String cachePath,\n                                                  TargetingKeywordsResolver resolver) {\n\n        return new TargetingKeywordsCreator(\n                PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n                includeWinners,\n                includeBidderKeys,\n                alwaysIncludeDeals,\n                includeFormat,\n                isApp,\n                truncateAttrChars,\n                cacheHost,\n                cachePath,\n                resolver);\n    }",
    "prod_code_tgt": "    /**\n     * Creates {@link TargetingKeywordsCreator} for the given params.\n     */\n    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n                                                  boolean includeWinners,\n                                                  boolean includeBidderKeys,\n                                                  boolean alwaysIncludeDeals,\n                                                  boolean includeFormat,\n                                                  boolean isApp,\n                                                  int truncateAttrChars,\n                                                  String cacheHost,\n                                                  String cachePath,\n                                                  TargetingKeywordsResolver resolver,\n                                                  String keyPrefix) {\n        return new TargetingKeywordsCreator(\n                PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n                includeWinners,\n                includeBidderKeys,\n                alwaysIncludeDeals,\n                includeFormat,\n                isApp,\n                truncateAttrChars,\n                cacheHost,\n                cachePath,\n                resolver,\n                keyPrefix);\n    }",
    "test_id": 13,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-12-07 16:20:04+02:00",
    "commit_src": "5108de36ce0d8a51605ad9281e133f4956448105",
    "commit_tgt": "96eda0b11ed826d09b815f3afff562d38766b549",
    "changed_test": "src/test/java/org/prebid/server/auction/TargetingKeywordsCreatorTest.java#shouldReturnTargetingKeywordsForWinningBidOpenrtb",
    "changed_prod": "src/main/java/org/prebid/server/auction/TargetingKeywordsCreator.java#create",
    "test_code_src": "    @Test\n    public void shouldReturnTargetingKeywordsForWinningBidOpenrtb() {\n        // given\n        final Bid bid = Bid.builder()\n                .price(BigDecimal.ONE)\n                .dealid(\"dealId1\")\n                .w(50)\n                .h(100)\n                .build();\n\n        // when\n        final Map<String, String> keywords = TargetingKeywordsCreator.create(\n                        ExtPriceGranularity.of(\n                                2,\n                                singletonList(ExtGranularityRange.of(BigDecimal.valueOf(5), BigDecimal.valueOf(0.5)))),\n                        true,\n                        true,\n                        false,\n                        true,\n                        false,\n                        0,\n                        null,\n                        null,\n                        null)\n                .makeFor(bid, \"bidder1\", true, \"cacheId1\", \"banner\", \"videoCacheId1\", \"categoryDuration\");\n\n        // then\n        assertThat(keywords).containsOnly(\n                entry(\"hb_pb_bidder1\", \"1.00\"),\n                entry(\"hb_bidder_bidder1\", \"bidder1\"),\n                entry(\"hb_size_bidder1\", \"50x100\"),\n                entry(\"hb_deal_bidder1\", \"dealId1\"),\n                entry(\"hb_pb\", \"1.00\"),\n                entry(\"hb_bidder\", \"bidder1\"),\n                entry(\"hb_size\", \"50x100\"),\n                entry(\"hb_deal\", \"dealId1\"),\n                entry(\"hb_cache_id\", \"cacheId1\"),\n                entry(\"hb_cache_id_bidder1\", \"cacheId1\"),\n                entry(\"hb_uuid\", \"videoCacheId1\"),\n                entry(\"hb_uuid_bidder1\", \"videoCacheId1\"),\n                entry(\"hb_format\", \"banner\"),\n                entry(\"hb_format_bidder1\", \"banner\"),\n                entry(\"hb_pb_cat_dur_bidder1\", \"categoryDuration\"),\n                entry(\"hb_pb_cat_dur\", \"categoryDuration\"));\n    }",
    "test_code_tgt": "    @Test\n    public void shouldReturnTargetingKeywordsForWinningBidOpenrtb() {\n        // given\n        final Bid bid = Bid.builder()\n                .price(BigDecimal.ONE)\n                .dealid(\"dealId1\")\n                .w(50)\n                .h(100)\n                .build();\n\n        // when\n        final Map<String, String> keywords = TargetingKeywordsCreator.create(\n                        ExtPriceGranularity.of(\n                                2,\n                                singletonList(ExtGranularityRange.of(BigDecimal.valueOf(5), BigDecimal.valueOf(0.5)))),\n                        true,\n                        true,\n                        false,\n                        true,\n                        false,\n                        0,\n                        null,\n                        null,\n                        null,\n                        defaultKeyPrefix)\n                .makeFor(bid, \"bidder1\", true, \"cacheId1\", \"banner\", \"videoCacheId1\", \"categoryDuration\");\n\n        // then\n        assertThat(keywords).containsOnly(\n                entry(\"hb_pb_bidder1\", \"1.00\"),\n                entry(\"hb_bidder_bidder1\", \"bidder1\"),\n                entry(\"hb_size_bidder1\", \"50x100\"),\n                entry(\"hb_deal_bidder1\", \"dealId1\"),\n                entry(\"hb_pb\", \"1.00\"),\n                entry(\"hb_bidder\", \"bidder1\"),\n                entry(\"hb_size\", \"50x100\"),\n                entry(\"hb_deal\", \"dealId1\"),\n                entry(\"hb_cache_id\", \"cacheId1\"),\n                entry(\"hb_cache_id_bidder1\", \"cacheId1\"),\n                entry(\"hb_uuid\", \"videoCacheId1\"),\n                entry(\"hb_uuid_bidder1\", \"videoCacheId1\"),\n                entry(\"hb_format\", \"banner\"),\n                entry(\"hb_format_bidder1\", \"banner\"),\n                entry(\"hb_pb_cat_dur_bidder1\", \"categoryDuration\"),\n                entry(\"hb_pb_cat_dur\", \"categoryDuration\"));\n    }",
    "prod_code_src": "    /**\n     * Creates {@link TargetingKeywordsCreator} for the given params.\n     */\n    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n                                                  boolean includeWinners,\n                                                  boolean includeBidderKeys,\n                                                  boolean alwaysIncludeDeals,\n                                                  boolean includeFormat,\n                                                  boolean isApp,\n                                                  int truncateAttrChars,\n                                                  String cacheHost,\n                                                  String cachePath,\n                                                  TargetingKeywordsResolver resolver) {\n\n        return new TargetingKeywordsCreator(\n                PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n                includeWinners,\n                includeBidderKeys,\n                alwaysIncludeDeals,\n                includeFormat,\n                isApp,\n                truncateAttrChars,\n                cacheHost,\n                cachePath,\n                resolver);\n    }",
    "prod_code_tgt": "    /**\n     * Creates {@link TargetingKeywordsCreator} for the given params.\n     */\n    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n                                                  boolean includeWinners,\n                                                  boolean includeBidderKeys,\n                                                  boolean alwaysIncludeDeals,\n                                                  boolean includeFormat,\n                                                  boolean isApp,\n                                                  int truncateAttrChars,\n                                                  String cacheHost,\n                                                  String cachePath,\n                                                  TargetingKeywordsResolver resolver,\n                                                  String keyPrefix) {\n        return new TargetingKeywordsCreator(\n                PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n                includeWinners,\n                includeBidderKeys,\n                alwaysIncludeDeals,\n                includeFormat,\n                isApp,\n                truncateAttrChars,\n                cacheHost,\n                cachePath,\n                resolver,\n                keyPrefix);\n    }",
    "test_id": 14,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-12-07 16:20:04+02:00",
    "commit_src": "5108de36ce0d8a51605ad9281e133f4956448105",
    "commit_tgt": "96eda0b11ed826d09b815f3afff562d38766b549",
    "changed_test": "src/test/java/org/prebid/server/auction/TargetingKeywordsCreatorTest.java#shouldTruncateTargetingBidderKeywordsIfTruncateAttrCharsIsDefined",
    "changed_prod": "src/main/java/org/prebid/server/auction/TargetingKeywordsCreator.java#create",
    "test_code_src": "    @Test\n    public void shouldTruncateTargetingBidderKeywordsIfTruncateAttrCharsIsDefined() {\n        // given\n        final Bid bid = Bid.builder().price(BigDecimal.ONE).build();\n\n        // when\n        final Map<String, String> keywords = TargetingKeywordsCreator.create(\n                        ExtPriceGranularity.of(\n                                2,\n                                singletonList(ExtGranularityRange.of(BigDecimal.valueOf(5), BigDecimal.valueOf(0.5)))),\n                        false,\n                        true,\n                        false,\n                        false,\n                        false,\n                        20,\n                        null,\n                        null,\n                        null)\n                .makeFor(bid, \"someVeryLongBidderName\", true, null, null, null, null);\n\n        // then\n        assertThat(keywords).hasSize(2)\n                .containsKeys(\"hb_bidder_someVeryLo\", \"hb_pb_someVeryLongBi\");\n    }",
    "test_code_tgt": "    @Test\n    public void shouldTruncateTargetingBidderKeywordsIfTruncateAttrCharsIsDefined() {\n        // given\n        final Bid bid = Bid.builder().price(BigDecimal.ONE).build();\n\n        // when\n        final Map<String, String> keywords = TargetingKeywordsCreator.create(\n                        ExtPriceGranularity.of(\n                                2,\n                                singletonList(ExtGranularityRange.of(BigDecimal.valueOf(5), BigDecimal.valueOf(0.5)))),\n                        false,\n                        true,\n                        false,\n                        false,\n                        false,\n                        20,\n                        null,\n                        null,\n                        null,\n                        defaultKeyPrefix)\n                .makeFor(bid, \"someVeryLongBidderName\", true, null, null, null, null);\n\n        // then\n        assertThat(keywords).hasSize(2)\n                .containsKeys(\"hb_bidder_someVeryLo\", \"hb_pb_someVeryLongBi\");\n    }",
    "prod_code_src": "    /**\n     * Creates {@link TargetingKeywordsCreator} for the given params.\n     */\n    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n                                                  boolean includeWinners,\n                                                  boolean includeBidderKeys,\n                                                  boolean alwaysIncludeDeals,\n                                                  boolean includeFormat,\n                                                  boolean isApp,\n                                                  int truncateAttrChars,\n                                                  String cacheHost,\n                                                  String cachePath,\n                                                  TargetingKeywordsResolver resolver) {\n\n        return new TargetingKeywordsCreator(\n                PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n                includeWinners,\n                includeBidderKeys,\n                alwaysIncludeDeals,\n                includeFormat,\n                isApp,\n                truncateAttrChars,\n                cacheHost,\n                cachePath,\n                resolver);\n    }",
    "prod_code_tgt": "    /**\n     * Creates {@link TargetingKeywordsCreator} for the given params.\n     */\n    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n                                                  boolean includeWinners,\n                                                  boolean includeBidderKeys,\n                                                  boolean alwaysIncludeDeals,\n                                                  boolean includeFormat,\n                                                  boolean isApp,\n                                                  int truncateAttrChars,\n                                                  String cacheHost,\n                                                  String cachePath,\n                                                  TargetingKeywordsResolver resolver,\n                                                  String keyPrefix) {\n        return new TargetingKeywordsCreator(\n                PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n                includeWinners,\n                includeBidderKeys,\n                alwaysIncludeDeals,\n                includeFormat,\n                isApp,\n                truncateAttrChars,\n                cacheHost,\n                cachePath,\n                resolver,\n                keyPrefix);\n    }",
    "test_id": 15,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-12-07 16:20:04+02:00",
    "commit_src": "5108de36ce0d8a51605ad9281e133f4956448105",
    "commit_tgt": "96eda0b11ed826d09b815f3afff562d38766b549",
    "changed_test": "src/test/java/org/prebid/server/auction/TargetingKeywordsCreatorTest.java#shouldNotIncludeDealBidTargetingIfAlwaysIncludeDealsFlagIsFalse",
    "changed_prod": "src/main/java/org/prebid/server/auction/TargetingKeywordsCreator.java#create",
    "test_code_src": "    @Test\n    public void shouldNotIncludeDealBidTargetingIfAlwaysIncludeDealsFlagIsFalse() {\n        // given\n        final Bid bid = Bid.builder().price(BigDecimal.ONE).dealid(\"dealId\").build();\n\n        // when\n        final Map<String, String> keywords = TargetingKeywordsCreator.create(\n                        ExtPriceGranularity.of(\n                                2,\n                                singletonList(ExtGranularityRange.of(BigDecimal.valueOf(5), BigDecimal.valueOf(0.5)))),\n                        false,\n                        false,\n                        false,\n                        false,\n                        false,\n                        0,\n                        null,\n                        null,\n                        null)\n                .makeFor(bid, \"bidder1\", false, null, null, null, null);\n\n        // then\n        assertThat(keywords).doesNotContainKeys(\"hb_bidder_bidder1\", \"hb_deal_bidder1\", \"hb_pb_bidder1\");\n    }",
    "test_code_tgt": "    @Test\n    public void shouldNotIncludeDealBidTargetingIfAlwaysIncludeDealsFlagIsFalse() {\n        // given\n        final Bid bid = Bid.builder().price(BigDecimal.ONE).dealid(\"dealId\").build();\n\n        // when\n        final Map<String, String> keywords = TargetingKeywordsCreator.create(\n                        ExtPriceGranularity.of(\n                                2,\n                                singletonList(ExtGranularityRange.of(BigDecimal.valueOf(5), BigDecimal.valueOf(0.5)))),\n                        false,\n                        false,\n                        false,\n                        false,\n                        false,\n                        0,\n                        null,\n                        null,\n                        null,\n                        defaultKeyPrefix)\n                .makeFor(bid, \"bidder1\", false, null, null, null, null);\n\n        // then\n        assertThat(keywords).doesNotContainKeys(\"hb_bidder_bidder1\", \"hb_deal_bidder1\", \"hb_pb_bidder1\");\n    }",
    "prod_code_src": "    /**\n     * Creates {@link TargetingKeywordsCreator} for the given params.\n     */\n    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n                                                  boolean includeWinners,\n                                                  boolean includeBidderKeys,\n                                                  boolean alwaysIncludeDeals,\n                                                  boolean includeFormat,\n                                                  boolean isApp,\n                                                  int truncateAttrChars,\n                                                  String cacheHost,\n                                                  String cachePath,\n                                                  TargetingKeywordsResolver resolver) {\n\n        return new TargetingKeywordsCreator(\n                PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n                includeWinners,\n                includeBidderKeys,\n                alwaysIncludeDeals,\n                includeFormat,\n                isApp,\n                truncateAttrChars,\n                cacheHost,\n                cachePath,\n                resolver);\n    }",
    "prod_code_tgt": "    /**\n     * Creates {@link TargetingKeywordsCreator} for the given params.\n     */\n    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n                                                  boolean includeWinners,\n                                                  boolean includeBidderKeys,\n                                                  boolean alwaysIncludeDeals,\n                                                  boolean includeFormat,\n                                                  boolean isApp,\n                                                  int truncateAttrChars,\n                                                  String cacheHost,\n                                                  String cachePath,\n                                                  TargetingKeywordsResolver resolver,\n                                                  String keyPrefix) {\n        return new TargetingKeywordsCreator(\n                PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n                includeWinners,\n                includeBidderKeys,\n                alwaysIncludeDeals,\n                includeFormat,\n                isApp,\n                truncateAttrChars,\n                cacheHost,\n                cachePath,\n                resolver,\n                keyPrefix);\n    }",
    "test_id": 16,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-07-12 15:05:36+03:00",
    "commit_src": "185953727d360361ec2a60d0e7f4e2f944a82034",
    "commit_tgt": "f46839a2aa369fd5aa517c3be6f928c5c796337c",
    "changed_test": "src/test/java/org/prebid/server/util/VersionInfoTest.java#shouldCreateVersionWithUndefinedForAllFieldsIfFileWasNotFound",
    "changed_prod": "src/main/java/org/prebid/server/util/VersionInfo.java#create",
    "test_code_src": "    @Test\n    public void shouldCreateVersionWithUndefinedForAllFieldsIfFileWasNotFound() {\n        // when\n        VersionInfo versionInfo = VersionInfo.create(\"not_found.json\", jacksonMapper);\n\n        // then\n        assertThat(versionInfo)\n                .extracting(VersionInfo::getVersion, VersionInfo::getCommitHash)\n                .containsOnly(\"undefined\", \"undefined\");\n    }",
    "test_code_tgt": "    @Test\n    public void shouldCreateVersionWithUndefinedForAllFieldsIfFileWasNotFound() {\n        // when\n        final VersionInfo versionInfo = VersionInfo.create(\"not_found.json\", jacksonMapper);\n\n        // then\n        assertThat(versionInfo)\n                .extracting(VersionInfo::getVersion, VersionInfo::getCommitHash)\n                .containsOnly(\"undefined\", \"undefined\");\n    }",
    "prod_code_src": "    public static VersionInfo create(String revisionFilePath, JacksonMapper jacksonMapper) {\n        Revision revision;\n        try {\n            revision = jacksonMapper.mapper().readValue(ResourceUtil.readFromClasspath(revisionFilePath),\n                    Revision.class);\n        } catch (IllegalArgumentException | IOException e) {\n            logger.error(\"Was not able to read revision file {0}. Reason: {1}\", revisionFilePath, e.getMessage());\n            return new VersionInfo(UNDEFINED, UNDEFINED);\n        }\n        final String pbsVersion = revision.getPbsVersion();\n        final String commitHash = revision.getCommitHash();\n        return new VersionInfo(\n                pbsVersion != null ? extractVersion(pbsVersion) : UNDEFINED,\n                commitHash != null ? commitHash : UNDEFINED);\n    }",
    "prod_code_tgt": "    public static VersionInfo create(String revisionFilePath, JacksonMapper jacksonMapper) {\n        final Revision revision;\n        try {\n            revision = jacksonMapper.mapper().readValue(ResourceUtil.readFromClasspath(revisionFilePath),\n                    Revision.class);\n        } catch (IllegalArgumentException | IOException e) {\n            logger.error(\"Was not able to read revision file {0}. Reason: {1}\", revisionFilePath, e.getMessage());\n            return new VersionInfo(UNDEFINED, UNDEFINED);\n        }\n        final String pbsVersion = revision.getPbsVersion();\n        final String commitHash = revision.getCommitHash();\n        return new VersionInfo(\n                pbsVersion != null ? extractVersion(pbsVersion) : UNDEFINED,\n                commitHash != null ? commitHash : UNDEFINED);\n    }",
    "test_id": 17,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-07-12 15:05:36+03:00",
    "commit_src": "185953727d360361ec2a60d0e7f4e2f944a82034",
    "commit_tgt": "f46839a2aa369fd5aa517c3be6f928c5c796337c",
    "changed_test": "src/test/java/org/prebid/server/util/VersionInfoTest.java#shouldCreateVersionWithUndefinedForEachMissingPropertyInFile",
    "changed_prod": "src/main/java/org/prebid/server/util/VersionInfo.java#create",
    "test_code_src": "    @Test\n    public void shouldCreateVersionWithUndefinedForEachMissingPropertyInFile() {\n        // when\n        VersionInfo versionInfo = VersionInfo.create(\n                \"org/prebid/server/util/resource/version/empty.json\", jacksonMapper);\n\n        // then\n        assertThat(versionInfo)\n                .extracting(VersionInfo::getVersion, VersionInfo::getCommitHash)\n                .containsOnly(\"undefined\", \"undefined\");\n    }",
    "test_code_tgt": "    @Test\n    public void shouldCreateVersionWithUndefinedForEachMissingPropertyInFile() {\n        // when\n        final VersionInfo versionInfo = VersionInfo.create(\n                \"org/prebid/server/util/resource/version/empty.json\", jacksonMapper);\n\n        // then\n        assertThat(versionInfo)\n                .extracting(VersionInfo::getVersion, VersionInfo::getCommitHash)\n                .containsOnly(\"undefined\", \"undefined\");\n    }",
    "prod_code_src": "    public static VersionInfo create(String revisionFilePath, JacksonMapper jacksonMapper) {\n        Revision revision;\n        try {\n            revision = jacksonMapper.mapper().readValue(ResourceUtil.readFromClasspath(revisionFilePath),\n                    Revision.class);\n        } catch (IllegalArgumentException | IOException e) {\n            logger.error(\"Was not able to read revision file {0}. Reason: {1}\", revisionFilePath, e.getMessage());\n            return new VersionInfo(UNDEFINED, UNDEFINED);\n        }\n        final String pbsVersion = revision.getPbsVersion();\n        final String commitHash = revision.getCommitHash();\n        return new VersionInfo(\n                pbsVersion != null ? extractVersion(pbsVersion) : UNDEFINED,\n                commitHash != null ? commitHash : UNDEFINED);\n    }",
    "prod_code_tgt": "    public static VersionInfo create(String revisionFilePath, JacksonMapper jacksonMapper) {\n        final Revision revision;\n        try {\n            revision = jacksonMapper.mapper().readValue(ResourceUtil.readFromClasspath(revisionFilePath),\n                    Revision.class);\n        } catch (IllegalArgumentException | IOException e) {\n            logger.error(\"Was not able to read revision file {0}. Reason: {1}\", revisionFilePath, e.getMessage());\n            return new VersionInfo(UNDEFINED, UNDEFINED);\n        }\n        final String pbsVersion = revision.getPbsVersion();\n        final String commitHash = revision.getCommitHash();\n        return new VersionInfo(\n                pbsVersion != null ? extractVersion(pbsVersion) : UNDEFINED,\n                commitHash != null ? commitHash : UNDEFINED);\n    }",
    "test_id": 18,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-07-12 15:05:36+03:00",
    "commit_src": "185953727d360361ec2a60d0e7f4e2f944a82034",
    "commit_tgt": "f46839a2aa369fd5aa517c3be6f928c5c796337c",
    "changed_test": "src/test/java/org/prebid/server/util/VersionInfoTest.java#shouldCreateVersionInfoWithAllProperties",
    "changed_prod": "src/main/java/org/prebid/server/util/VersionInfo.java#create",
    "test_code_src": "    @Test\n    public void shouldCreateVersionInfoWithAllProperties() {\n        // when\n        VersionInfo versionInfo = VersionInfo.create(\n                \"org/prebid/server/util/resource/version/version.json\", jacksonMapper);\n\n        // then\n        assertThat(versionInfo)\n                .extracting(VersionInfo::getVersion, VersionInfo::getCommitHash)\n                .containsOnly(\"1.41.0\", \"4df3f6192d7938ccdaac04df783c46c7e8847d08\");\n    }",
    "test_code_tgt": "    @Test\n    public void shouldCreateVersionInfoWithAllProperties() {\n        // when\n        final VersionInfo versionInfo = VersionInfo.create(\n                \"org/prebid/server/util/resource/version/version.json\", jacksonMapper);\n\n        // then\n        assertThat(versionInfo)\n                .extracting(VersionInfo::getVersion, VersionInfo::getCommitHash)\n                .containsOnly(\"1.41.0\", \"4df3f6192d7938ccdaac04df783c46c7e8847d08\");\n    }",
    "prod_code_src": "    public static VersionInfo create(String revisionFilePath, JacksonMapper jacksonMapper) {\n        Revision revision;\n        try {\n            revision = jacksonMapper.mapper().readValue(ResourceUtil.readFromClasspath(revisionFilePath),\n                    Revision.class);\n        } catch (IllegalArgumentException | IOException e) {\n            logger.error(\"Was not able to read revision file {0}. Reason: {1}\", revisionFilePath, e.getMessage());\n            return new VersionInfo(UNDEFINED, UNDEFINED);\n        }\n        final String pbsVersion = revision.getPbsVersion();\n        final String commitHash = revision.getCommitHash();\n        return new VersionInfo(\n                pbsVersion != null ? extractVersion(pbsVersion) : UNDEFINED,\n                commitHash != null ? commitHash : UNDEFINED);\n    }",
    "prod_code_tgt": "    public static VersionInfo create(String revisionFilePath, JacksonMapper jacksonMapper) {\n        final Revision revision;\n        try {\n            revision = jacksonMapper.mapper().readValue(ResourceUtil.readFromClasspath(revisionFilePath),\n                    Revision.class);\n        } catch (IllegalArgumentException | IOException e) {\n            logger.error(\"Was not able to read revision file {0}. Reason: {1}\", revisionFilePath, e.getMessage());\n            return new VersionInfo(UNDEFINED, UNDEFINED);\n        }\n        final String pbsVersion = revision.getPbsVersion();\n        final String commitHash = revision.getCommitHash();\n        return new VersionInfo(\n                pbsVersion != null ? extractVersion(pbsVersion) : UNDEFINED,\n                commitHash != null ? commitHash : UNDEFINED);\n    }",
    "test_id": 19,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-06-29 16:22:12+03:00",
    "commit_src": "8b40c0322b6dd0c4c87ab7198a4c4fa323d48f26",
    "commit_tgt": "4b9fb727c114ade2f8eca53411d0566266ed1abc",
    "changed_test": "src/test/java/org/prebid/server/auction/ImplicitParametersExtractorTest.java#gpcFromShouldReturn1OnInteger",
    "changed_prod": "src/main/java/org/prebid/server/auction/ImplicitParametersExtractor.java#gpcFrom",
    "test_code_src": "    @Test\n    public void gpcFromShouldReturn1OnInteger() {\n        // given\n        final HttpRequestContext httpRequest = HttpRequestContext.builder()\n                .headers(CaseInsensitiveMultiMap.builder()\n                        .add(HttpUtil.SEC_GPC, \"1\")\n                        .build())\n                .build();\n\n        // when\n        final String gpc = extractor.gpcFrom(httpRequest);\n\n        // then\n        assertThat(gpc).isEqualTo(\"1\");\n    }",
    "test_code_tgt": "    @Test\n    public void gpcFromShouldReturn1OnInteger() {\n        // given\n        final HttpRequestContext httpRequest = HttpRequestContext.builder()\n                .headers(CaseInsensitiveMultiMap.builder()\n                        .add(HttpUtil.SEC_GPC_HEADER, \"1\")\n                        .build())\n                .build();\n\n        // when\n        final String gpc = extractor.gpcFrom(httpRequest);\n\n        // then\n        assertThat(gpc).isEqualTo(\"1\");\n    }",
    "prod_code_src": "    public String gpcFrom(HttpRequestContext httpRequest) {\n        final String gpcAsString = httpRequest.getHeaders().get(HttpUtil.SEC_GPC);\n        return \"1\".equals(gpcAsString) || \"\\\"1\\\"\".equals(gpcAsString) ? \"1\" : null;\n    }",
    "prod_code_tgt": "    public String gpcFrom(HttpRequestContext httpRequest) {\n        final String gpcAsString = httpRequest.getHeaders().get(HttpUtil.SEC_GPC_HEADER);\n        return \"1\".equals(gpcAsString) || \"\\\"1\\\"\".equals(gpcAsString) ? \"1\" : null;\n    }",
    "test_id": 20,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-06-29 16:22:12+03:00",
    "commit_src": "8b40c0322b6dd0c4c87ab7198a4c4fa323d48f26",
    "commit_tgt": "4b9fb727c114ade2f8eca53411d0566266ed1abc",
    "changed_test": "src/test/java/org/prebid/server/auction/ImplicitParametersExtractorTest.java#gpcFromShouldReturn1OnString",
    "changed_prod": "src/main/java/org/prebid/server/auction/ImplicitParametersExtractor.java#gpcFrom",
    "test_code_src": "    @Test\n    public void gpcFromShouldReturn1OnString() {\n        // given\n        final HttpRequestContext httpRequest = HttpRequestContext.builder()\n                .headers(CaseInsensitiveMultiMap.builder()\n                        .add(HttpUtil.SEC_GPC, \"\\\"1\\\"\")\n                        .build())\n                .build();\n\n        // when\n        final String gpc = extractor.gpcFrom(httpRequest);\n\n        // then\n        assertThat(gpc).isEqualTo(\"1\");\n    }",
    "test_code_tgt": "    @Test\n    public void gpcFromShouldReturn1OnString() {\n        // given\n        final HttpRequestContext httpRequest = HttpRequestContext.builder()\n                .headers(CaseInsensitiveMultiMap.builder()\n                        .add(HttpUtil.SEC_GPC_HEADER, \"\\\"1\\\"\")\n                        .build())\n                .build();\n\n        // when\n        final String gpc = extractor.gpcFrom(httpRequest);\n\n        // then\n        assertThat(gpc).isEqualTo(\"1\");\n    }",
    "prod_code_src": "    public String gpcFrom(HttpRequestContext httpRequest) {\n        final String gpcAsString = httpRequest.getHeaders().get(HttpUtil.SEC_GPC);\n        return \"1\".equals(gpcAsString) || \"\\\"1\\\"\".equals(gpcAsString) ? \"1\" : null;\n    }",
    "prod_code_tgt": "    public String gpcFrom(HttpRequestContext httpRequest) {\n        final String gpcAsString = httpRequest.getHeaders().get(HttpUtil.SEC_GPC_HEADER);\n        return \"1\".equals(gpcAsString) || \"\\\"1\\\"\".equals(gpcAsString) ? \"1\" : null;\n    }",
    "test_id": 21,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  },
  {
    "repo_name": "prebid/prebid-server-java",
    "commit_date": "2023-02-06 14:09:21+02:00",
    "commit_src": "12f8d379c9e459820217db1a2a2cdb496cdb33a8",
    "commit_tgt": "5be24a1314fb3ed68d6c9e87ef20e803dc6d9a5e",
    "changed_test": "src/test/java/org/prebid/server/deals/simulation/SimulationAwareHttpBidderRequesterTest.java#requestBidsShouldReturnBidderSeatBidWithoutBidderBidsAndWithError",
    "changed_prod": "src/main/java/org/prebid/server/deals/simulation/SimulationAwareHttpBidderRequester.java#requestBids",
    "test_code_src": "    @Test\n    public void requestBidsShouldReturnBidderSeatBidWithoutBidderBidsAndWithError() {\n        // given\n        bidderRequester.setBidRates(Collections.singletonMap(\"lineItemId1\", 1.00));\n\n        final BidRequest bidRequest = BidRequest.builder().imp(singletonList(\n                        Imp.builder().id(\"impId1\").pmp(Pmp.builder().deals(singletonList(Deal.builder()\n                                .id(\"dealId1\").build())).build()).build()))\n                .build();\n        final BidderRequest bidderRequest = BidderRequest.of(\"bidder\", null, null, bidRequest);\n\n        // when\n        final Future<BidderSeatBid> result = bidderRequester\n                .requestBids(\n                        null,\n                        bidderRequest,\n                        null,\n                        requestHeaders,\n                        bidderAliases,\n                        false);\n\n        // then\n        assertThat(result.succeeded()).isTrue();\n        assertThat(result.result()).isEqualTo(BidderSeatBid.of(\n                emptyList(),\n                emptyList(),\n                singletonList(BidderError.failedToRequestBids(\n                        \"Matched or ready to serve line items were not found, but required in simulation mode\")),\n                emptyList()));\n    }",
    "test_code_tgt": "    @Test\n    public void requestBidsShouldReturnBidderSeatBidWithoutBidderBidsAndWithError() {\n        // given\n        bidderRequester.setBidRates(Collections.singletonMap(\"lineItemId1\", 1.00));\n\n        final BidRequest bidRequest = BidRequest.builder().imp(singletonList(\n                        Imp.builder().id(\"impId1\").pmp(Pmp.builder().deals(singletonList(Deal.builder()\n                                .id(\"dealId1\").build())).build()).build()))\n                .build();\n        final BidderRequest bidderRequest = BidderRequest.of(\"bidder\", null, null, bidRequest);\n\n        // when\n        final Future<BidderSeatBid> result = bidderRequester\n                .requestBids(\n                        null,\n                        bidderRequest,\n                        null,\n                        requestHeaders,\n                        bidderAliases,\n                        false);\n\n        // then\n        assertThat(result.succeeded()).isTrue();\n        assertThat(result.result()).isEqualTo(BidderSeatBid.builder()\n                .errors(singletonList(BidderError.failedToRequestBids(\n                        \"Matched or ready to serve line items were not found, but required in simulation mode\")))\n                .build());\n    }",
    "prod_code_src": "    @Override\n    public <T> Future<BidderSeatBid> requestBids(Bidder<T> bidder,\n                                                 BidderRequest bidderRequest,\n                                                 Timeout timeout,\n                                                 CaseInsensitiveMultiMap requestHeaders,\n                                                 BidderAliases aliases,\n                                                 boolean debugEnabled) {\n\n        final List<Imp> imps = bidderRequest.getBidRequest().getImp();\n        final Map<String, Imp> idToImps = imps.stream().collect(Collectors.toMap(Imp::getId, Function.identity()));\n        final Map<String, Set<DealInfo>> impsToDealInfo = imps.stream()\n                .filter(imp -> imp.getPmp() != null)\n                .collect(Collectors.toMap(Imp::getId, imp -> imp.getPmp().getDeals().stream()\n                        .map(deal -> DealInfo.of(deal.getId(), getLineItemId(deal)))\n                        .filter(dealInfo -> dealInfo.getLineItemId() != null)\n                        .collect(Collectors.toSet())));\n\n        if (impsToDealInfo.values().stream().noneMatch(CollectionUtils::isNotEmpty)) {\n            return Future.succeededFuture(BidderSeatBid.of(\n                    Collections.emptyList(),\n                    Collections.emptyList(),\n                    Collections.singletonList(BidderError.failedToRequestBids(\n                            \"Matched or ready to serve line items were not found, but required in simulation mode\")),\n                    Collections.emptyList()));\n        }\n\n        final List<BidderBid> bidderBids = impsToDealInfo.entrySet().stream()\n                .flatMap(impToDealInfo -> impToDealInfo.getValue()\n                        .stream()\n                        .map(dealInfo -> createBid(idToImps.get(impToDealInfo.getKey()), dealInfo.getDealId(),\n                                dealInfo.getLineItemId()))\n                        .filter(Objects::nonNull))\n                .map(bid -> BidderBid.of(bid, BidType.banner, DEFAULT_CURRENCY))\n                .toList();\n\n        return Future.succeededFuture(BidderSeatBid.of(bidderBids));\n    }",
    "prod_code_tgt": "    @Override\n    public <T> Future<BidderSeatBid> requestBids(Bidder<T> bidder,\n                                                 BidderRequest bidderRequest,\n                                                 Timeout timeout,\n                                                 CaseInsensitiveMultiMap requestHeaders,\n                                                 BidderAliases aliases,\n                                                 boolean debugEnabled) {\n\n        final List<Imp> imps = bidderRequest.getBidRequest().getImp();\n        final Map<String, Imp> idToImps = imps.stream().collect(Collectors.toMap(Imp::getId, Function.identity()));\n        final Map<String, Set<DealInfo>> impsToDealInfo = imps.stream()\n                .filter(imp -> imp.getPmp() != null)\n                .collect(Collectors.toMap(Imp::getId, imp -> imp.getPmp().getDeals().stream()\n                        .map(deal -> DealInfo.of(deal.getId(), getLineItemId(deal)))\n                        .filter(dealInfo -> dealInfo.getLineItemId() != null)\n                        .collect(Collectors.toSet())));\n\n        if (impsToDealInfo.values().stream().noneMatch(CollectionUtils::isNotEmpty)) {\n            return Future.succeededFuture(BidderSeatBid.builder()\n                    .errors(Collections.singletonList(BidderError.failedToRequestBids(\n                            \"Matched or ready to serve line items were not found, but required in simulation mode\")))\n                    .build());\n        }\n\n        final List<BidderBid> bidderBids = impsToDealInfo.entrySet().stream()\n                .flatMap(impToDealInfo -> impToDealInfo.getValue()\n                        .stream()\n                        .map(dealInfo -> createBid(idToImps.get(impToDealInfo.getKey()), dealInfo.getDealId(),\n                                dealInfo.getLineItemId()))\n                        .filter(Objects::nonNull))\n                .map(bid -> BidderBid.of(bid, BidType.banner, DEFAULT_CURRENCY))\n                .toList();\n\n        return Future.succeededFuture(BidderSeatBid.of(bidderBids));\n    }",
    "test_id": 23,
    "src_java_version": "17",
    "src_maven_version": "3.8.1",
    "tgt_java_version": "17",
    "tgt_maven_version": "3.8.1"
  }
]