[
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2024-12-14 10:08:54+08:00",
    "commit_src": "9aa081b8acfd01a40f50bd9c3face3c0d2c530b1",
    "commit_tgt": "b5cf3ca90aba1765519ccd3244dc31e3852051ea",
    "changed_test": "broker/src/test/java/org/apache/rocketmq/broker/client/net/Broker2ClientTest.java#testResetOffsetNoTopicConfig",
    "changed_prod": "broker/src/main/java/org/apache/rocketmq/broker/client/net/Broker2Client.java#resetOffset",
    "test_code_src": "@Test\n    public void testResetOffsetNoTopicConfig() throws RemotingCommandException {\n        when(topicConfigManager.selectTopicConfig(defaultTopic)).thenReturn(null);\n        RemotingCommand response = broker2Client.resetOffset(defaultTopic, defaultGroup, timestamp, isForce);\n        assertEquals(ResponseCode.SYSTEM_ERROR, response.getCode());\n    }",
    "test_code_tgt": "@Test\n    public void testResetOffsetNoTopicConfig() throws RemotingCommandException {\n        when(topicConfigManager.selectTopicConfig(defaultTopic)).thenReturn(null);\n        RemotingCommand response = broker2Client.resetOffset(defaultTopic, defaultGroup, timestamp, isForce);\n        assertEquals(ResponseCode.TOPIC_NOT_EXIST, response.getCode());\n    }",
    "prod_code_src": "public RemotingCommand resetOffset(String topic, String group, long timeStamp, boolean isForce) throws RemotingCommandException {\n        return resetOffset(topic, group, timeStamp, isForce, false);\n    }",
    "prod_code_tgt": "public RemotingCommand resetOffset(String topic, String group, long timeStamp, boolean isForce,\n        boolean isC) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(topic);\n        if (null == topicConfig) {\n            log.error(\"[reset-offset] reset offset failed, no topic in this broker. topic={}\", topic);\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(\"[reset-offset] reset offset failed, no topic in this broker. topic=\" + topic);\n            return response;\n        }\n\n        Map<MessageQueue, Long> offsetTable = new HashMap<>();\n\n        for (int i = 0; i < topicConfig.getWriteQueueNums(); i++) {\n            MessageQueue mq = new MessageQueue();\n            mq.setBrokerName(this.brokerController.getBrokerConfig().getBrokerName());\n            mq.setTopic(topic);\n            mq.setQueueId(i);\n\n            long consumerOffset =\n                this.brokerController.getConsumerOffsetManager().queryOffset(group, topic, i);\n            if (-1 == consumerOffset) {\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(String.format(\"THe consumer group <%s> not exist\", group));\n                return response;\n            }\n\n            long timeStampOffset;\n            if (timeStamp == -1) {\n                try {\n                    timeStampOffset = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, i);\n                } catch (ConsumeQueueException e) {\n                    throw new RemotingCommandException(\"Failed to get max offset in queue\", e);\n                }\n            } else {\n                timeStampOffset = this.brokerController.getMessageStore().getOffsetInQueueByTime(topic, i, timeStamp);\n            }\n\n            if (timeStampOffset < 0) {\n                log.warn(\"reset offset is invalid. topic={}, queueId={}, timeStampOffset={}\", topic, i, timeStampOffset);\n                timeStampOffset = 0;\n            }\n\n            if (isForce || timeStampOffset < consumerOffset) {\n                offsetTable.put(mq, timeStampOffset);\n            } else {\n                offsetTable.put(mq, consumerOffset);\n            }\n        }\n\n        ResetOffsetRequestHeader requestHeader = new ResetOffsetRequestHeader();\n        requestHeader.setTopic(topic);\n        requestHeader.setGroup(group);\n        requestHeader.setTimestamp(timeStamp);\n        RemotingCommand request =\n            RemotingCommand.createRequestCommand(RequestCode.RESET_CONSUMER_CLIENT_OFFSET, requestHeader);\n        if (isC) {\n            // c++ language\n            ResetOffsetBodyForC body = new ResetOffsetBodyForC();\n            List<MessageQueueForC> offsetList = convertOffsetTable2OffsetList(offsetTable);\n            body.setOffsetTable(offsetList);\n            request.setBody(body.encode());\n        } else {\n            // other language\n            ResetOffsetBody body = new ResetOffsetBody();\n            body.setOffsetTable(offsetTable);\n            request.setBody(body.encode());\n        }\n\n        ConsumerGroupInfo consumerGroupInfo =\n            this.brokerController.getConsumerManager().getConsumerGroupInfo(group);\n\n        if (consumerGroupInfo != null && !consumerGroupInfo.getAllChannel().isEmpty()) {\n            ConcurrentMap<Channel, ClientChannelInfo> channelInfoTable =\n                consumerGroupInfo.getChannelInfoTable();\n            for (Map.Entry<Channel, ClientChannelInfo> entry : channelInfoTable.entrySet()) {\n                int version = entry.getValue().getVersion();\n                if (version >= MQVersion.Version.V3_0_7_SNAPSHOT.ordinal()) {\n                    try {\n                        this.brokerController.getRemotingServer().invokeOneway(entry.getKey(), request, 5000);\n                        log.info(\"[reset-offset] reset offset success. topic={}, group={}, clientId={}\",\n                            topic, group, entry.getValue().getClientId());\n                    } catch (Exception e) {\n                        log.error(\"[reset-offset] reset offset exception. topic={}, group={} ,error={}\",\n                            topic, group, e.toString());\n                    }\n                } else {\n                    response.setCode(ResponseCode.SYSTEM_ERROR);\n                    response.setRemark(\"the client does not support this feature. version=\"\n                        + MQVersion.getVersionDesc(version));\n                    log.warn(\"[reset-offset] the client does not support this feature. channel={}, version={}\",\n                        RemotingHelper.parseChannelRemoteAddr(entry.getKey()), MQVersion.getVersionDesc(version));\n                    return response;\n                }\n            }\n        } else {\n            String errorInfo =\n                String.format(\"Consumer not online, so can not reset offset, Group: %s Topic: %s Timestamp: %d\",\n                    requestHeader.getGroup(),\n                    requestHeader.getTopic(),\n                    requestHeader.getTimestamp());\n            log.error(errorInfo);\n            response.setCode(ResponseCode.CONSUMER_NOT_ONLINE);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        response.setCode(ResponseCode.SUCCESS);\n        ResetOffsetBody resBody = new ResetOffsetBody();\n        resBody.setOffsetTable(offsetTable);\n        response.setBody(resBody.encode());\n        return response;\n    }",
    "test_id": 0,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2024-12-14 10:08:54+08:00",
    "commit_src": "9aa081b8acfd01a40f50bd9c3face3c0d2c530b1",
    "commit_tgt": "b5cf3ca90aba1765519ccd3244dc31e3852051ea",
    "changed_test": "broker/src/test/java/org/apache/rocketmq/broker/processor/PeekMessageProcessorTest.java#testProcessRequest_QueueIdError",
    "changed_prod": "broker/src/main/java/org/apache/rocketmq/broker/processor/PeekMessageProcessor.java#processRequest",
    "test_code_src": "@Test\n    public void testProcessRequest_QueueIdError() throws RemotingCommandException {\n        RemotingCommand request = createPeekMessageRequest(\"group\",\"topic\",17);\n        RemotingCommand response = peekMessageProcessor.processRequest(handlerContext, request);\n        assertThat(response.getCode()).isEqualTo(ResponseCode.SYSTEM_ERROR);\n    }",
    "test_code_tgt": "@Test\n    public void testProcessRequest_QueueIdError() throws RemotingCommandException {\n        RemotingCommand request = createPeekMessageRequest(\"group\",\"topic\",17);\n        RemotingCommand response = peekMessageProcessor.processRequest(handlerContext, request);\n        assertThat(response.getCode()).isEqualTo(ResponseCode.INVALID_PARAMETER);\n    }",
    "prod_code_src": "@Override\n    public RemotingCommand processRequest(final ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        return this.processRequest(ctx.channel(), request, true);\n    }",
    "prod_code_tgt": "private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend)\n        throws RemotingCommandException {\n        final long beginTimeMills = this.brokerController.getMessageStore().now();\n        RemotingCommand response = RemotingCommand.createResponseCommand(PopMessageResponseHeader.class);\n        final PopMessageResponseHeader responseHeader = (PopMessageResponseHeader) response.readCustomHeader();\n        final PeekMessageRequestHeader requestHeader =\n            (PeekMessageRequestHeader) request.decodeCommandCustomHeader(PeekMessageRequestHeader.class);\n\n        response.setOpaque(request.getOpaque());\n\n        if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(String.format(\"the broker[%s] peeking message is forbidden\", this.brokerController.getBrokerConfig().getBrokerIP1()));\n            return response;\n        }\n\n        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            LOG.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel));\n            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n            response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n            return response;\n        }\n\n        if (!PermName.isReadable(topicConfig.getPerm())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] peeking message is forbidden\");\n            return response;\n        }\n\n        if (requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n            String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]\",\n                requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress());\n            LOG.warn(errorInfo);\n            response.setCode(ResponseCode.INVALID_PARAMETER);\n            response.setRemark(errorInfo);\n            return response;\n        }\n        SubscriptionGroupConfig subscriptionGroupConfig = this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n        if (null == subscriptionGroupConfig) {\n            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n            response.setRemark(String.format(\"subscription group [%s] does not exist, %s\", requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n            return response;\n        }\n\n        if (!subscriptionGroupConfig.isConsumeEnable()) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n            return response;\n        }\n        int randomQ = random.nextInt(100);\n        int reviveQid = randomQ % this.brokerController.getBrokerConfig().getReviveQueueNum();\n        GetMessageResult getMessageResult = new GetMessageResult(requestHeader.getMaxMsgNums());\n        boolean needRetry = randomQ % 5 == 0;\n        long popTime = System.currentTimeMillis();\n        long restNum = 0;\n        BrokerConfig brokerConfig = brokerController.getBrokerConfig();\n        if (needRetry) {\n            TopicConfig retryTopicConfig = this.brokerController.getTopicConfigManager()\n                .selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup(), brokerConfig.isEnableRetryTopicV2()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    restNum = peekMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime);\n                }\n            }\n        }\n        if (requestHeader.getQueueId() < 0) {\n            // read all queue\n            for (int i = 0; i < topicConfig.getReadQueueNums(); i++) {\n                int queueId = (randomQ + i) % topicConfig.getReadQueueNums();\n                restNum = peekMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime);\n            }\n        } else {\n            int queueId = requestHeader.getQueueId();\n            restNum = peekMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime);\n        }\n        // if not full , fetch retry again\n        if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums()) {\n            TopicConfig retryTopicConfig = this.brokerController.getTopicConfigManager()\n                .selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup(), brokerConfig.isEnableRetryTopicV2()));\n            if (retryTopicConfig != null) {\n                for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) {\n                    int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums();\n                    restNum = peekMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime);\n                }\n            }\n        }\n        if (!getMessageResult.getMessageBufferList().isEmpty()) {\n            response.setCode(ResponseCode.SUCCESS);\n            getMessageResult.setStatus(GetMessageStatus.FOUND);\n        } else {\n            response.setCode(ResponseCode.PULL_NOT_FOUND);\n            getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE);\n\n        }\n        responseHeader.setRestNum(restNum);\n        response.setRemark(getMessageResult.getStatus().name());\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS:\n\n                this.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),\n                    getMessageResult.getMessageCount());\n\n                this.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),\n                    getMessageResult.getBufferTotalSize());\n\n                this.brokerController.getBrokerStatsManager().incBrokerGetNums(requestHeader.getTopic(), getMessageResult.getMessageCount());\n\n                if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) {\n                    final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());\n                    this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n                        requestHeader.getTopic(), requestHeader.getQueueId(),\n                        (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n                    response.setBody(r);\n                } else {\n                    final GetMessageResult tmpGetMessageResult = getMessageResult;\n                    try {\n                        FileRegion fileRegion =\n                            new ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);\n                        RemotingCommand finalResponse = response;\n                        channel.writeAndFlush(fileRegion)\n                            .addListener((ChannelFutureListener) future -> {\n                                tmpGetMessageResult.release();\n                                Attributes attributes = RemotingMetricsManager.newAttributesBuilder()\n                                    .put(LABEL_REQUEST_CODE, RemotingHelper.getRequestCodeDesc(request.getCode()))\n                                    .put(LABEL_RESPONSE_CODE, RemotingHelper.getResponseCodeDesc(finalResponse.getCode()))\n                                    .put(LABEL_RESULT, RemotingMetricsManager.getWriteAndFlushResult(future))\n                                    .build();\n                                RemotingMetricsManager.rpcLatency.record(request.getProcessTimer().elapsed(TimeUnit.MILLISECONDS), attributes);\n                                if (!future.isSuccess()) {\n                                    LOG.error(\"Fail to transfer messages from page cache to {}\", channel.remoteAddress(), future.cause());\n                                }\n                            });\n                    } catch (Throwable e) {\n                        LOG.error(\"Error occurred when transferring messages from page cache\", e);\n                        getMessageResult.release();\n                    }\n\n                    response = null;\n                }\n                break;\n            default:\n                assert false;\n        }\n        return response;\n    }",
    "test_id": 1,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2024-11-14 19:24:19+08:00",
    "commit_src": "66ba4566f5ebaeac47c73eaaf4a86567e3760063",
    "commit_tgt": "87b97f271c96bdbb320b1e127cbeaaa4e83c4c2a",
    "changed_test": "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/route/RouteActivityTest.java#testGenPartitionFromQueueData",
    "changed_prod": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/route/RouteActivity.java#genMessageQueueFromQueueData",
    "test_code_src": "@Test\n    public void testGenPartitionFromQueueData() throws Exception {\n        // test queueData with 8 read queues, 8 write queues, and rw permission, expect 8 rw queues.\n        QueueData queueDataWith8R8WPermRW = createQueueData(8, 8, PermName.PERM_READ | PermName.PERM_WRITE);\n        List<MessageQueue> partitionWith8R8WPermRW = this.routeActivity.genMessageQueueFromQueueData(queueDataWith8R8WPermRW, GRPC_TOPIC, TopicMessageType.NORMAL, GRPC_BROKER);\n        assertEquals(8, partitionWith8R8WPermRW.size());\n        assertEquals(8, partitionWith8R8WPermRW.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.NORMAL.getNumber()).count());\n        assertEquals(8, partitionWith8R8WPermRW.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith8R8WPermRW.stream().filter(a -> a.getPermission() == Permission.READ).count());\n        assertEquals(0, partitionWith8R8WPermRW.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n\n        // test queueData with 8 read queues, 8 write queues, and read only permission, expect 8 read only queues.\n        QueueData queueDataWith8R8WPermR = createQueueData(8, 8, PermName.PERM_READ);\n        List<MessageQueue> partitionWith8R8WPermR = this.routeActivity.genMessageQueueFromQueueData(queueDataWith8R8WPermR, GRPC_TOPIC, TopicMessageType.FIFO, GRPC_BROKER);\n        assertEquals(8, partitionWith8R8WPermR.size());\n        assertEquals(8, partitionWith8R8WPermR.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.FIFO.getNumber()).count());\n        assertEquals(8, partitionWith8R8WPermR.stream().filter(a -> a.getPermission() == Permission.READ).count());\n        assertEquals(0, partitionWith8R8WPermR.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith8R8WPermR.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n\n        // test queueData with 8 read queues, 8 write queues, and write only permission, expect 8 write only queues.\n        QueueData queueDataWith8R8WPermW = createQueueData(8, 8, PermName.PERM_WRITE);\n        List<MessageQueue> partitionWith8R8WPermW = this.routeActivity.genMessageQueueFromQueueData(queueDataWith8R8WPermW, GRPC_TOPIC, TopicMessageType.TRANSACTION, GRPC_BROKER);\n        assertEquals(8, partitionWith8R8WPermW.size());\n        assertEquals(8, partitionWith8R8WPermW.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.TRANSACTION.getNumber()).count());\n        assertEquals(8, partitionWith8R8WPermW.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n        assertEquals(0, partitionWith8R8WPermW.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith8R8WPermW.stream().filter(a -> a.getPermission() == Permission.READ).count());\n\n        // test queueData with 8 read queues, 0 write queues, and rw permission, expect 8 read only queues.\n        QueueData queueDataWith8R0WPermRW = createQueueData(8, 0, PermName.PERM_READ | PermName.PERM_WRITE);\n        List<MessageQueue> partitionWith8R0WPermRW = this.routeActivity.genMessageQueueFromQueueData(queueDataWith8R0WPermRW, GRPC_TOPIC, TopicMessageType.DELAY, GRPC_BROKER);\n        assertEquals(8, partitionWith8R0WPermRW.size());\n        assertEquals(8, partitionWith8R0WPermRW.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.DELAY.getNumber()).count());\n        assertEquals(8, partitionWith8R0WPermRW.stream().filter(a -> a.getPermission() == Permission.READ).count());\n        assertEquals(0, partitionWith8R0WPermRW.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith8R0WPermRW.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n\n        // test queueData with 4 read queues, 8 write queues, and rw permission, expect 4 rw queues and  4 write only queues.\n        QueueData queueDataWith4R8WPermRW = createQueueData(4, 8, PermName.PERM_READ | PermName.PERM_WRITE);\n        List<MessageQueue> partitionWith4R8WPermRW = this.routeActivity.genMessageQueueFromQueueData(queueDataWith4R8WPermRW, GRPC_TOPIC, TopicMessageType.UNSPECIFIED, GRPC_BROKER);\n        assertEquals(8, partitionWith4R8WPermRW.size());\n        assertEquals(8, partitionWith4R8WPermRW.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.MESSAGE_TYPE_UNSPECIFIED.getNumber()).count());\n        assertEquals(4, partitionWith4R8WPermRW.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n        assertEquals(4, partitionWith4R8WPermRW.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith4R8WPermRW.stream().filter(a -> a.getPermission() == Permission.READ).count());\n    }",
    "test_code_tgt": "@Test\n    public void testGenPartitionFromQueueData() throws Exception {\n        // test queueData with 8 read queues, 8 write queues, and rw permission, expect 8 rw queues.\n        QueueData queueDataWith8R8WPermRW = createQueueData(8, 8, PermName.PERM_READ | PermName.PERM_WRITE);\n        List<MessageQueue> partitionWith8R8WPermRW = this.routeActivity.genMessageQueueFromQueueData(queueDataWith8R8WPermRW, GRPC_TOPIC, TopicMessageType.NORMAL, GRPC_BROKER);\n        assertEquals(8, partitionWith8R8WPermRW.size());\n        assertEquals(8, partitionWith8R8WPermRW.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.NORMAL.getNumber()).count());\n        assertEquals(8, partitionWith8R8WPermRW.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith8R8WPermRW.stream().filter(a -> a.getPermission() == Permission.READ).count());\n        assertEquals(0, partitionWith8R8WPermRW.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n\n        // test queueData with 8 read queues, 8 write queues, and read only permission, expect 8 read only queues.\n        QueueData queueDataWith8R8WPermR = createQueueData(8, 8, PermName.PERM_READ);\n        List<MessageQueue> partitionWith8R8WPermR = this.routeActivity.genMessageQueueFromQueueData(queueDataWith8R8WPermR, GRPC_TOPIC, TopicMessageType.FIFO, GRPC_BROKER);\n        assertEquals(8, partitionWith8R8WPermR.size());\n        assertEquals(8, partitionWith8R8WPermR.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.FIFO.getNumber()).count());\n        assertEquals(8, partitionWith8R8WPermR.stream().filter(a -> a.getPermission() == Permission.READ).count());\n        assertEquals(0, partitionWith8R8WPermR.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith8R8WPermR.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n\n        // test queueData with 8 read queues, 8 write queues, and write only permission, expect 8 write only queues.\n        QueueData queueDataWith8R8WPermW = createQueueData(8, 8, PermName.PERM_WRITE);\n        List<MessageQueue> partitionWith8R8WPermW = this.routeActivity.genMessageQueueFromQueueData(queueDataWith8R8WPermW, GRPC_TOPIC, TopicMessageType.TRANSACTION, GRPC_BROKER);\n        assertEquals(8, partitionWith8R8WPermW.size());\n        assertEquals(8, partitionWith8R8WPermW.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.TRANSACTION.getNumber()).count());\n        assertEquals(8, partitionWith8R8WPermW.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n        assertEquals(0, partitionWith8R8WPermW.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith8R8WPermW.stream().filter(a -> a.getPermission() == Permission.READ).count());\n\n        // test queueData with 8 read queues, 0 write queues, and rw permission, expect 8 read only queues.\n        QueueData queueDataWith8R0WPermRW = createQueueData(8, 0, PermName.PERM_READ | PermName.PERM_WRITE);\n        List<MessageQueue> partitionWith8R0WPermRW = this.routeActivity.genMessageQueueFromQueueData(queueDataWith8R0WPermRW, GRPC_TOPIC, TopicMessageType.DELAY, GRPC_BROKER);\n        assertEquals(8, partitionWith8R0WPermRW.size());\n        assertEquals(8, partitionWith8R0WPermRW.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.DELAY.getNumber()).count());\n        assertEquals(8, partitionWith8R0WPermRW.stream().filter(a -> a.getPermission() == Permission.READ).count());\n        assertEquals(0, partitionWith8R0WPermRW.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith8R0WPermRW.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n\n        // test queueData with 4 read queues, 8 write queues, and rw permission, expect 4 rw queues and  4 write only queues.\n        QueueData queueDataWith4R8WPermRW = createQueueData(4, 8, PermName.PERM_READ | PermName.PERM_WRITE);\n        List<MessageQueue> partitionWith4R8WPermRW = this.routeActivity.genMessageQueueFromQueueData(queueDataWith4R8WPermRW, GRPC_TOPIC, TopicMessageType.UNSPECIFIED, GRPC_BROKER);\n        assertEquals(8, partitionWith4R8WPermRW.size());\n        assertEquals(8, partitionWith4R8WPermRW.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.MESSAGE_TYPE_UNSPECIFIED.getNumber()).count());\n        assertEquals(4, partitionWith4R8WPermRW.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n        assertEquals(4, partitionWith4R8WPermRW.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith4R8WPermRW.stream().filter(a -> a.getPermission() == Permission.READ).count());\n\n        // test queueData with 2 read queues, 2 write queues, and no permission, expect 2 no permission queues.\n        QueueData queueDataWith2R2WNoPerm = createQueueData(2, 2, 0);\n        List<MessageQueue> partitionWith2R2WNoPerm = this.routeActivity.genMessageQueueFromQueueData(queueDataWith2R2WNoPerm, GRPC_TOPIC, TopicMessageType.UNSPECIFIED, GRPC_BROKER);\n        assertEquals(2, partitionWith2R2WNoPerm.size());\n        assertEquals(2, partitionWith2R2WNoPerm.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.MESSAGE_TYPE_UNSPECIFIED.getNumber()).count());\n        assertEquals(2, partitionWith2R2WNoPerm.stream().filter(a -> a.getPermission() == Permission.NONE).count());\n        assertEquals(0, partitionWith2R2WNoPerm.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n        assertEquals(0, partitionWith2R2WNoPerm.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith2R2WNoPerm.stream().filter(a -> a.getPermission() == Permission.READ).count());\n\n        // test queueData with 0 read queues, 0 write queues, and no permission, expect 1 no permission queue.\n        QueueData queueDataWith0R0WNoPerm = createQueueData(0, 0, 0);\n        List<MessageQueue> partitionWith0R0WNoPerm = this.routeActivity.genMessageQueueFromQueueData(queueDataWith0R0WNoPerm, GRPC_TOPIC, TopicMessageType.UNSPECIFIED, GRPC_BROKER);\n        assertEquals(1, partitionWith0R0WNoPerm.size());\n        assertEquals(1, partitionWith0R0WNoPerm.stream().filter(a -> a.getAcceptMessageTypesValue(0) == MessageType.MESSAGE_TYPE_UNSPECIFIED.getNumber()).count());\n        assertEquals(1, partitionWith0R0WNoPerm.stream().filter(a -> a.getPermission() == Permission.NONE).count());\n        assertEquals(0, partitionWith0R0WNoPerm.stream().filter(a -> a.getPermission() == Permission.WRITE).count());\n        assertEquals(0, partitionWith0R0WNoPerm.stream().filter(a -> a.getPermission() == Permission.READ_WRITE).count());\n        assertEquals(0, partitionWith0R0WNoPerm.stream().filter(a -> a.getPermission() == Permission.READ).count());\n    }",
    "prod_code_src": "protected List<MessageQueue> genMessageQueueFromQueueData(QueueData queueData, Resource topic,\n        TopicMessageType topicMessageType, Broker broker) {\n        List<MessageQueue> messageQueueList = new ArrayList<>();\n\n        int r = 0;\n        int w = 0;\n        int rw = 0;\n        if (PermName.isWriteable(queueData.getPerm()) && PermName.isReadable(queueData.getPerm())) {\n            rw = Math.min(queueData.getWriteQueueNums(), queueData.getReadQueueNums());\n            r = queueData.getReadQueueNums() - rw;\n            w = queueData.getWriteQueueNums() - rw;\n        } else if (PermName.isWriteable(queueData.getPerm())) {\n            w = queueData.getWriteQueueNums();\n        } else if (PermName.isReadable(queueData.getPerm())) {\n            r = queueData.getReadQueueNums();\n        }\n\n        // r here means readOnly queue nums, w means writeOnly queue nums, while rw means both readable and writable queue nums.\n        int queueIdIndex = 0;\n        for (int i = 0; i < r; i++) {\n            MessageQueue messageQueue = MessageQueue.newBuilder().setBroker(broker).setTopic(topic)\n                .setId(queueIdIndex++)\n                .setPermission(Permission.READ)\n                .addAllAcceptMessageTypes(parseTopicMessageType(topicMessageType))\n                .build();\n            messageQueueList.add(messageQueue);\n        }\n\n        for (int i = 0; i < w; i++) {\n            MessageQueue messageQueue = MessageQueue.newBuilder().setBroker(broker).setTopic(topic)\n                .setId(queueIdIndex++)\n                .setPermission(Permission.WRITE)\n                .addAllAcceptMessageTypes(parseTopicMessageType(topicMessageType))\n                .build();\n            messageQueueList.add(messageQueue);\n        }\n\n        for (int i = 0; i < rw; i++) {\n            MessageQueue messageQueue = MessageQueue.newBuilder().setBroker(broker).setTopic(topic)\n                .setId(queueIdIndex++)\n                .setPermission(Permission.READ_WRITE)\n                .addAllAcceptMessageTypes(parseTopicMessageType(topicMessageType))\n                .build();\n            messageQueueList.add(messageQueue);\n        }\n\n        return messageQueueList;\n    }",
    "prod_code_tgt": "protected List<MessageQueue> genMessageQueueFromQueueData(QueueData queueData, Resource topic,\n        TopicMessageType topicMessageType, Broker broker) {\n        List<MessageQueue> messageQueueList = new ArrayList<>();\n\n        int r = 0;\n        int w = 0;\n        int rw = 0;\n        int n = 0;\n        if (PermName.isWriteable(queueData.getPerm()) && PermName.isReadable(queueData.getPerm())) {\n            rw = Math.min(queueData.getWriteQueueNums(), queueData.getReadQueueNums());\n            r = queueData.getReadQueueNums() - rw;\n            w = queueData.getWriteQueueNums() - rw;\n        } else if (PermName.isWriteable(queueData.getPerm())) {\n            w = queueData.getWriteQueueNums();\n        } else if (PermName.isReadable(queueData.getPerm())) {\n            r = queueData.getReadQueueNums();\n        } else if (!PermName.isAccessible(queueData.getPerm())) {\n            n = Math.max(1, Math.max(queueData.getWriteQueueNums(), queueData.getReadQueueNums()));\n        }\n\n        // r here means readOnly queue nums, w means writeOnly queue nums, while rw means both readable and writable queue nums.\n        int queueIdIndex = 0;\n        for (int i = 0; i < r; i++) {\n            MessageQueue messageQueue = MessageQueue.newBuilder().setBroker(broker).setTopic(topic)\n                .setId(queueIdIndex++)\n                .setPermission(Permission.READ)\n                .addAllAcceptMessageTypes(parseTopicMessageType(topicMessageType))\n                .build();\n            messageQueueList.add(messageQueue);\n        }\n\n        for (int i = 0; i < w; i++) {\n            MessageQueue messageQueue = MessageQueue.newBuilder().setBroker(broker).setTopic(topic)\n                .setId(queueIdIndex++)\n                .setPermission(Permission.WRITE)\n                .addAllAcceptMessageTypes(parseTopicMessageType(topicMessageType))\n                .build();\n            messageQueueList.add(messageQueue);\n        }\n\n        for (int i = 0; i < rw; i++) {\n            MessageQueue messageQueue = MessageQueue.newBuilder().setBroker(broker).setTopic(topic)\n                .setId(queueIdIndex++)\n                .setPermission(Permission.READ_WRITE)\n                .addAllAcceptMessageTypes(parseTopicMessageType(topicMessageType))\n                .build();\n            messageQueueList.add(messageQueue);\n        }\n\n        for (int i = 0; i < n; i++) {\n            MessageQueue messageQueue = MessageQueue.newBuilder().setBroker(broker).setTopic(topic)\n                .setId(queueIdIndex++)\n                .setPermission(Permission.NONE)\n                .addAllAcceptMessageTypes(parseTopicMessageType(topicMessageType))\n                .build();\n            messageQueueList.add(messageQueue);\n        }\n\n        return messageQueueList;\n    }",
    "test_id": 2,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2024-01-23 13:56:26+08:00",
    "commit_src": "6d7513425c2aeb17e527be9d0d98d47f7251927d",
    "commit_tgt": "5262358140bcf7b283754a71dd16c2a5c6dbf821",
    "changed_test": "client/src/test/java/org/apache/rocketmq/client/rpchook/NamespaceRpcHookTest.java#testDoBeforeRequestWithNamespace",
    "changed_prod": "client/src/main/java/org/apache/rocketmq/client/rpchook/NamespaceRpcHook.java#doBeforeRequest",
    "test_code_src": "@Test\n    public void testDoBeforeRequestWithNamespace() {\n        clientConfig = new ClientConfig();\n        clientConfig.setNamespaceV2(namespace);\n        namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n        PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n        namespaceRpcHook.doBeforeRequest(\"\", request);\n        assertThat(pullMessageRequestHeader.getNamespaced()).isTrue();\n        assertThat(pullMessageRequestHeader.getNamespace()).isEqualTo(namespace);\n    }",
    "test_code_tgt": "@Test\n    public void testDoBeforeRequestWithNamespace() {\n        clientConfig = new ClientConfig();\n        clientConfig.setNamespaceV2(namespace);\n        namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n        PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n        namespaceRpcHook.doBeforeRequest(\"\", request);\n        assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD)).isEqualTo(\"true\");\n        assertThat(request.getExtFields().get(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD)).isEqualTo(namespace);\n    }",
    "prod_code_src": "@Override\n    public void doBeforeRequest(String remoteAddr, RemotingCommand request) {\n        CommandCustomHeader customHeader = request.readCustomHeader();\n        if (customHeader instanceof RpcRequestHeader) {\n            RpcRequestHeader requestHeader = (RpcRequestHeader) customHeader;\n            if (StringUtils.isNotEmpty(clientConfig.getNamespaceV2())) {\n                requestHeader.setNamespaced(true);\n                requestHeader.setNamespace(clientConfig.getNamespaceV2());\n            }\n        }\n    }",
    "prod_code_tgt": "@Override\n    public void doBeforeRequest(String remoteAddr, RemotingCommand request) {\n        if (StringUtils.isNotEmpty(clientConfig.getNamespaceV2())) {\n            request.addExtField(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD, \"true\");\n            request.addExtField(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD, clientConfig.getNamespaceV2());\n        }\n    }",
    "test_id": 4,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2024-01-23 13:56:26+08:00",
    "commit_src": "6d7513425c2aeb17e527be9d0d98d47f7251927d",
    "commit_tgt": "5262358140bcf7b283754a71dd16c2a5c6dbf821",
    "changed_test": "client/src/test/java/org/apache/rocketmq/client/rpchook/NamespaceRpcHookTest.java#testDoBeforeRequestWithoutNamespace",
    "changed_prod": "client/src/main/java/org/apache/rocketmq/client/rpchook/NamespaceRpcHook.java#doBeforeRequest",
    "test_code_src": "@Test\n    public void testDoBeforeRequestWithoutNamespace() {\n        clientConfig = new ClientConfig();\n        namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n        PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n        namespaceRpcHook.doBeforeRequest(\"\", request);\n        assertThat(pullMessageRequestHeader.getNamespaced()).isNull();\n        assertThat(pullMessageRequestHeader.getNamespace()).isNull();\n    }",
    "test_code_tgt": "@Test\n    public void testDoBeforeRequestWithoutNamespace() {\n        clientConfig = new ClientConfig();\n        namespaceRpcHook = new NamespaceRpcHook(clientConfig);\n        PullMessageRequestHeader pullMessageRequestHeader = new PullMessageRequestHeader();\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, pullMessageRequestHeader);\n        namespaceRpcHook.doBeforeRequest(\"\", request);\n        assertThat(request.getExtFields()).isNull();\n    }",
    "prod_code_src": "@Override\n    public void doBeforeRequest(String remoteAddr, RemotingCommand request) {\n        CommandCustomHeader customHeader = request.readCustomHeader();\n        if (customHeader instanceof RpcRequestHeader) {\n            RpcRequestHeader requestHeader = (RpcRequestHeader) customHeader;\n            if (StringUtils.isNotEmpty(clientConfig.getNamespaceV2())) {\n                requestHeader.setNamespaced(true);\n                requestHeader.setNamespace(clientConfig.getNamespaceV2());\n            }\n        }\n    }",
    "prod_code_tgt": "@Override\n    public void doBeforeRequest(String remoteAddr, RemotingCommand request) {\n        if (StringUtils.isNotEmpty(clientConfig.getNamespaceV2())) {\n            request.addExtField(MixAll.RPC_REQUEST_HEADER_NAMESPACED_FIELD, \"true\");\n            request.addExtField(MixAll.RPC_REQUEST_HEADER_NAMESPACE_FIELD, clientConfig.getNamespaceV2());\n        }\n    }",
    "test_id": 5,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2023-07-18 20:58:56+08:00",
    "commit_src": "737c1e53383350a5671fa207ee0e4ce932850bac",
    "commit_tgt": "7996ec3b3f7ccea01f66951ac639b48303bbf7a6",
    "changed_test": "common/src/test/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtilsTest.java#computeIfAbsent",
    "changed_prod": "common/src/main/java/org/apache/rocketmq/common/utils/ConcurrentHashMapUtils.java#computeIfAbsent",
    "test_code_src": "@Test\n    public void computeIfAbsent() {\n\n        ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n        map.put(\"123\", \"1111\");\n        String value = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"234\");\n        assertEquals(\"1111\", value);\n        String value1 = ConcurrentHashMapUtils.computeIfAbsent(map, \"1232\", k -> \"2342\");\n        assertEquals(\"2342\", value1);\n        String value2 = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"2342\");\n        assertEquals(\"1111\", value2);\n    }",
    "test_code_tgt": "@Test\n    public void computeIfAbsent() {\n\n        ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n        map.put(\"123\", \"1111\");\n        String value = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"234\");\n        assertEquals(\"1111\", value);\n        String value1 = ConcurrentHashMapUtils.computeIfAbsent(map, \"1232\", k -> \"2342\");\n        assertEquals(\"2342\", value1);\n        String value2 = ConcurrentHashMapUtils.computeIfAbsent(map, \"123\", k -> \"2342\");\n        assertEquals(\"1111\", value2);\n//        map.computeIfAbsent(\"AaAa\", key->map.computeIfAbsent(\"BBBB\",key2->\"42\"));\n        ConcurrentHashMapUtils.computeIfAbsent(map, \"AaAa\", key -> map.computeIfAbsent(\"BBBB\", key2 -> \"42\"));\n    }",
    "prod_code_src": "public static <K, V> V computeIfAbsent(ConcurrentMap<K, V> map, K key, Function<? super K, ? extends V> func) {\n        if (isJdk8) {\n            V v = map.get(key);\n            if (null == v) {\n                v = map.computeIfAbsent(key, func);\n            }\n            return v;\n        } else {\n            return map.computeIfAbsent(key, func);\n        }\n    }",
    "prod_code_tgt": "public static <K, V> V computeIfAbsent(ConcurrentMap<K, V> map, K key, Function<? super K, ? extends V> func) {\n        Objects.requireNonNull(func);\n        if (isJdk8) {\n            V v = map.get(key);\n            if (null == v) {\n//                v = map.computeIfAbsent(key, func);\n\n                // this bug fix methods maybe cause `func.apply` multiple calls.\n                v = func.apply(key);\n                if (null == v) {\n                    return null;\n                }\n                final V res = map.putIfAbsent(key, v);\n                if (null != res) {\n                    // if pre value present, means other thread put value already, and putIfAbsent not effect\n                    // return exist value\n                    return res;\n                }\n            }\n            return v;\n        } else {\n            return map.computeIfAbsent(key, func);\n        }\n    }",
    "test_id": 7,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2023-07-11 17:04:00+08:00",
    "commit_src": "49ccdc9d2ad6c8ed04c21436e52e3b592eecd428",
    "commit_tgt": "15c6889bb0abd014c06ef1452f791db9daa1ea08",
    "changed_test": "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java#testReceiveMessagePollingTime",
    "changed_prod": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java#receiveMessage",
    "test_code_src": "@Test\n    public void testReceiveMessagePollingTime() {\n        StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n        ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n        doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n        ArgumentCaptor<Long> pollTimeCaptor = ArgumentCaptor.forClass(Long.class);\n        when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder()\n            .setRequestTimeout(Durations.fromSeconds(3))\n            .build());\n        when(this.messagingProcessor.popMessage(any(), any(), anyString(), anyString(), anyInt(), anyLong(),\n            pollTimeCaptor.capture(), anyInt(), any(), anyBoolean(), any(), anyString(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new PopResult(PopStatus.NO_NEW_MSG, Collections.emptyList())));\n\n\n        ProxyContext context = createContext();\n        context.setRemainingMs(1L);\n        this.receiveMessageActivity.receiveMessage(\n            context,\n            ReceiveMessageRequest.newBuilder()\n                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n                .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n                .setAutoRenew(true)\n                .setFilterExpression(FilterExpression.newBuilder()\n                    .setType(FilterType.TAG)\n                    .setExpression(\"*\")\n                    .build())\n                .build(),\n            receiveStreamObserver\n        );\n\n        assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n        assertEquals(0L, pollTimeCaptor.getValue().longValue());\n    }",
    "test_code_tgt": "@Test\n    public void testReceiveMessagePollingTime() {\n        StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n        ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n        doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n        ArgumentCaptor<Long> pollTimeCaptor = ArgumentCaptor.forClass(Long.class);\n        when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder()\n            .setRequestTimeout(Durations.fromSeconds(3))\n            .build());\n        when(this.messagingProcessor.popMessage(any(), any(), anyString(), anyString(), anyInt(), anyLong(),\n            pollTimeCaptor.capture(), anyInt(), any(), anyBoolean(), any(), isNull(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(new PopResult(PopStatus.NO_NEW_MSG, Collections.emptyList())));\n\n\n        ProxyContext context = createContext();\n        context.setRemainingMs(1L);\n        this.receiveMessageActivity.receiveMessage(\n            context,\n            ReceiveMessageRequest.newBuilder()\n                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n                .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n                .setAutoRenew(true)\n                .setFilterExpression(FilterExpression.newBuilder()\n                    .setType(FilterType.TAG)\n                    .setExpression(\"*\")\n                    .build())\n                .build(),\n            receiveStreamObserver\n        );\n\n        assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n        assertEquals(0L, pollTimeCaptor.getValue().longValue());\n    }",
    "prod_code_src": "public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    request.getAttemptId(),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    messagingProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }",
    "prod_code_tgt": "public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    request.hasAttemptId() ? request.getAttemptId() : null,\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    messagingProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }",
    "test_id": 8,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2023-07-11 17:04:00+08:00",
    "commit_src": "49ccdc9d2ad6c8ed04c21436e52e3b592eecd428",
    "commit_tgt": "15c6889bb0abd014c06ef1452f791db9daa1ea08",
    "changed_test": "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java#testReceiveMessage",
    "changed_prod": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java#receiveMessage",
    "test_code_src": "@Test\n    public void testReceiveMessage() {\n        StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n        ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n        doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n        when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder().getDefaultInstanceForType());\n\n        PopResult popResult = new PopResult(PopStatus.NO_NEW_MSG, new ArrayList<>());\n        when(this.messagingProcessor.popMessage(\n            any(),\n            any(),\n            anyString(),\n            anyString(),\n            anyInt(),\n            anyLong(),\n            anyLong(),\n            anyInt(),\n            any(),\n            anyBoolean(),\n            any(),\n            anyString(),\n            anyLong())).thenReturn(CompletableFuture.completedFuture(popResult));\n\n        this.receiveMessageActivity.receiveMessage(\n            createContext(),\n            ReceiveMessageRequest.newBuilder()\n                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n                .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n                .setAutoRenew(true)\n                .setFilterExpression(FilterExpression.newBuilder()\n                    .setType(FilterType.TAG)\n                    .setExpression(\"*\")\n                    .build())\n                .build(),\n            receiveStreamObserver\n        );\n        assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n    }",
    "test_code_tgt": "@Test\n    public void testReceiveMessage() {\n        StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n        ArgumentCaptor<ReceiveMessageResponse> responseArgumentCaptor = ArgumentCaptor.forClass(ReceiveMessageResponse.class);\n        doNothing().when(receiveStreamObserver).onNext(responseArgumentCaptor.capture());\n\n        when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder().getDefaultInstanceForType());\n\n        PopResult popResult = new PopResult(PopStatus.NO_NEW_MSG, new ArrayList<>());\n        when(this.messagingProcessor.popMessage(\n            any(),\n            any(),\n            anyString(),\n            anyString(),\n            anyInt(),\n            anyLong(),\n            anyLong(),\n            anyInt(),\n            any(),\n            anyBoolean(),\n            any(),\n            isNull(),\n            anyLong())).thenReturn(CompletableFuture.completedFuture(popResult));\n\n        this.receiveMessageActivity.receiveMessage(\n            createContext(),\n            ReceiveMessageRequest.newBuilder()\n                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n                .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n                .setAutoRenew(true)\n                .setFilterExpression(FilterExpression.newBuilder()\n                    .setType(FilterType.TAG)\n                    .setExpression(\"*\")\n                    .build())\n                .build(),\n            receiveStreamObserver\n        );\n        assertEquals(Code.MESSAGE_NOT_FOUND, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n    }",
    "prod_code_src": "public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    request.getAttemptId(),\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    messagingProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }",
    "prod_code_tgt": "public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n        StreamObserver<ReceiveMessageResponse> responseObserver) {\n        ReceiveMessageResponseStreamWriter writer = createWriter(ctx, responseObserver);\n\n        try {\n            Settings settings = this.grpcClientSettingsManager.getClientSettings(ctx);\n            Subscription subscription = settings.getSubscription();\n            boolean fifo = subscription.getFifo();\n            int maxAttempts = settings.getBackoffPolicy().getMaxAttempts();\n            ProxyConfig config = ConfigurationManager.getProxyConfig();\n\n            Long timeRemaining = ctx.getRemainingMs();\n            long pollingTime;\n            if (request.hasLongPollingTimeout()) {\n                pollingTime = Durations.toMillis(request.getLongPollingTimeout());\n            } else {\n                pollingTime = timeRemaining - Durations.toMillis(settings.getRequestTimeout()) / 2;\n            }\n            if (pollingTime < config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMinLongPollingTimeoutMillis();\n            }\n            if (pollingTime > config.getGrpcClientConsumerMaxLongPollingTimeoutMillis()) {\n                pollingTime = config.getGrpcClientConsumerMaxLongPollingTimeoutMillis();\n            }\n\n            if (pollingTime > timeRemaining) {\n                if (timeRemaining >= config.getGrpcClientConsumerMinLongPollingTimeoutMillis()) {\n                    pollingTime = timeRemaining;\n                } else {\n                    final String clientVersion = ctx.getClientVersion();\n                    Code code =\n                        null == clientVersion || ILLEGAL_POLLING_TIME_INTRODUCED_CLIENT_VERSION.compareTo(clientVersion) > 0 ?\n                        Code.BAD_REQUEST : Code.ILLEGAL_POLLING_TIME;\n                    writer.writeAndComplete(ctx, code, \"The deadline time remaining is not enough\" +\n                        \" for polling, please check network condition\");\n                    return;\n                }\n            }\n\n            validateTopicAndConsumerGroup(request.getMessageQueue().getTopic(), request.getGroup());\n            String topic = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getMessageQueue().getTopic());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            long actualInvisibleTime = Durations.toMillis(request.getInvisibleDuration());\n            ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n            if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                actualInvisibleTime = proxyConfig.getDefaultInvisibleTimeMills();\n            } else {\n                validateInvisibleTime(actualInvisibleTime,\n                    ConfigurationManager.getProxyConfig().getMinInvisibleTimeMillsForRecv());\n            }\n\n            FilterExpression filterExpression = request.getFilterExpression();\n            SubscriptionData subscriptionData;\n            try {\n                subscriptionData = FilterAPI.build(topic, filterExpression.getExpression(),\n                    GrpcConverter.getInstance().buildExpressionType(filterExpression.getType()));\n            } catch (Exception e) {\n                writer.writeAndComplete(ctx, Code.ILLEGAL_FILTER_EXPRESSION, e.getMessage());\n                return;\n            }\n\n            this.messagingProcessor.popMessage(\n                    ctx,\n                    new ReceiveMessageQueueSelector(\n                        request.getMessageQueue().getBroker().getName()\n                    ),\n                    group,\n                    topic,\n                    request.getBatchSize(),\n                    actualInvisibleTime,\n                    pollingTime,\n                    ConsumeInitMode.MAX,\n                    subscriptionData,\n                    fifo,\n                    new PopMessageResultFilterImpl(maxAttempts),\n                    request.hasAttemptId() ? request.getAttemptId() : null,\n                    timeRemaining\n                ).thenAccept(popResult -> {\n                    if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                        if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n                            List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                            for (MessageExt messageExt : messageExtList) {\n                                String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n                                if (receiptHandle != null) {\n                                    MessageReceiptHandle messageReceiptHandle =\n                                        new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                            messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n                                    messagingProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n                                }\n                            }\n                        }\n                    }\n                    writer.writeAndComplete(ctx, request, popResult);\n                })\n                .exceptionally(t -> {\n                    writer.writeAndComplete(ctx, request, t);\n                    return null;\n                });\n        } catch (Throwable t) {\n            writer.writeAndComplete(ctx, request, t);\n        }\n    }",
    "test_id": 9,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2023-06-06 17:07:06+08:00",
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_test": "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ChangeInvisibleDurationActivityTest.java#testChangeInvisibleDurationActivityWhenHasMappingHandle",
    "changed_prod": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ChangeInvisibleDurationActivity.java#changeInvisibleDuration",
    "test_code_src": "@Test\n    public void testChangeInvisibleDurationActivityWhenHasMappingHandle() throws Throwable {\n        String newHandle = \"newHandle\";\n        ArgumentCaptor<Long> invisibleTimeArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n        AckResult ackResult = new AckResult();\n        ackResult.setExtraInfo(newHandle);\n        ackResult.setStatus(AckStatus.OK);\n        String savedHandleStr = buildReceiptHandle(\"topic\", System.currentTimeMillis(),3000);\n        ArgumentCaptor<ReceiptHandle> receiptHandleCaptor = ArgumentCaptor.forClass(ReceiptHandle.class);\n        when(this.messagingProcessor.changeInvisibleTime(\n            any(), receiptHandleCaptor.capture(), anyString(), anyString(), anyString(), invisibleTimeArgumentCaptor.capture()\n        )).thenReturn(CompletableFuture.completedFuture(ackResult));\n        when(receiptHandleProcessor.removeReceiptHandle(any(), anyString(), anyString(), anyString()))\n            .thenReturn(new MessageReceiptHandle(\"group\", \"topic\", 0, savedHandleStr, \"msgId\", 0, 0));\n\n        ChangeInvisibleDurationResponse response = this.changeInvisibleDurationActivity.changeInvisibleDuration(\n            createContext(),\n            ChangeInvisibleDurationRequest.newBuilder()\n                .setInvisibleDuration(Durations.fromSeconds(3))\n                .setTopic(Resource.newBuilder().setName(TOPIC).build())\n                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n                .setMessageId(\"msgId\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build()\n        ).get();\n\n        assertEquals(Code.OK, response.getStatus().getCode());\n        assertEquals(TimeUnit.SECONDS.toMillis(3), invisibleTimeArgumentCaptor.getValue().longValue());\n        assertEquals(savedHandleStr, receiptHandleCaptor.getValue().getReceiptHandle());\n        assertEquals(newHandle, response.getReceiptHandle());\n    }",
    "test_code_tgt": "@Test\n    public void testChangeInvisibleDurationActivityWhenHasMappingHandle() throws Throwable {\n        String newHandle = \"newHandle\";\n        ArgumentCaptor<Long> invisibleTimeArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n        AckResult ackResult = new AckResult();\n        ackResult.setExtraInfo(newHandle);\n        ackResult.setStatus(AckStatus.OK);\n        String savedHandleStr = buildReceiptHandle(\"topic\", System.currentTimeMillis(),3000);\n        ArgumentCaptor<ReceiptHandle> receiptHandleCaptor = ArgumentCaptor.forClass(ReceiptHandle.class);\n        when(this.messagingProcessor.changeInvisibleTime(\n            any(), receiptHandleCaptor.capture(), anyString(), anyString(), anyString(), invisibleTimeArgumentCaptor.capture()\n        )).thenReturn(CompletableFuture.completedFuture(ackResult));\n        when(receiptHandleProcessor.removeReceiptHandle(any(), any(), anyString(), anyString(), anyString()))\n            .thenReturn(new MessageReceiptHandle(\"group\", \"topic\", 0, savedHandleStr, \"msgId\", 0, 0));\n\n        ChangeInvisibleDurationResponse response = this.changeInvisibleDurationActivity.changeInvisibleDuration(\n            createContext(),\n            ChangeInvisibleDurationRequest.newBuilder()\n                .setInvisibleDuration(Durations.fromSeconds(3))\n                .setTopic(Resource.newBuilder().setName(TOPIC).build())\n                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n                .setMessageId(\"msgId\")\n                .setReceiptHandle(buildReceiptHandle(TOPIC, System.currentTimeMillis(), 3000))\n                .build()\n        ).get();\n\n        assertEquals(Code.OK, response.getStatus().getCode());\n        assertEquals(TimeUnit.SECONDS.toMillis(3), invisibleTimeArgumentCaptor.getValue().longValue());\n        assertEquals(savedHandleStr, receiptHandleCaptor.getValue().getReceiptHandle());\n        assertEquals(newHandle, response.getReceiptHandle());\n    }",
    "prod_code_src": "public CompletableFuture<ChangeInvisibleDurationResponse> changeInvisibleDuration(ProxyContext ctx,\n        ChangeInvisibleDurationRequest request) {\n        CompletableFuture<ChangeInvisibleDurationResponse> future = new CompletableFuture<>();\n\n        try {\n            validateTopicAndConsumerGroup(request.getTopic(), request.getGroup());\n            validateInvisibleTime(Durations.toMillis(request.getInvisibleDuration()));\n\n            ReceiptHandle receiptHandle = ReceiptHandle.decode(request.getReceiptHandle());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            MessageReceiptHandle messageReceiptHandle = receiptHandleProcessor.removeReceiptHandle(grpcChannelManager.getChannel(ctx.getClientID()), group, request.getMessageId(), receiptHandle.getReceiptHandle());\n            if (messageReceiptHandle != null) {\n                receiptHandle = ReceiptHandle.decode(messageReceiptHandle.getReceiptHandleStr());\n            }\n            return this.messagingProcessor.changeInvisibleTime(\n                ctx,\n                receiptHandle,\n                request.getMessageId(),\n                group,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(request.getTopic()),\n                Durations.toMillis(request.getInvisibleDuration())\n            ).thenApply(ackResult -> convertToChangeInvisibleDurationResponse(ctx, request, ackResult));\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }",
    "prod_code_tgt": "public CompletableFuture<ChangeInvisibleDurationResponse> changeInvisibleDuration(ProxyContext ctx,\n        ChangeInvisibleDurationRequest request) {\n        CompletableFuture<ChangeInvisibleDurationResponse> future = new CompletableFuture<>();\n\n        try {\n            validateTopicAndConsumerGroup(request.getTopic(), request.getGroup());\n            validateInvisibleTime(Durations.toMillis(request.getInvisibleDuration()));\n\n            ReceiptHandle receiptHandle = ReceiptHandle.decode(request.getReceiptHandle());\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n\n            MessageReceiptHandle messageReceiptHandle = receiptHandleProcessor.removeReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, request.getMessageId(), receiptHandle.getReceiptHandle());\n            if (messageReceiptHandle != null) {\n                receiptHandle = ReceiptHandle.decode(messageReceiptHandle.getReceiptHandleStr());\n            }\n            return this.messagingProcessor.changeInvisibleTime(\n                ctx,\n                receiptHandle,\n                request.getMessageId(),\n                group,\n                GrpcConverter.getInstance().wrapResourceWithNamespace(request.getTopic()),\n                Durations.toMillis(request.getInvisibleDuration())\n            ).thenApply(ackResult -> convertToChangeInvisibleDurationResponse(ctx, request, ackResult));\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }",
    "test_id": 10,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2023-06-06 17:07:06+08:00",
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_test": "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/producer/ForwardMessageToDLQActivityTest.java#testForwardMessageToDeadLetterQueueWhenHasMappingHandle",
    "changed_prod": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/producer/ForwardMessageToDLQActivity.java#forwardMessageToDeadLetterQueue",
    "test_code_src": "@Test\n    public void testForwardMessageToDeadLetterQueueWhenHasMappingHandle() throws Throwable {\n        ArgumentCaptor<ReceiptHandle> receiptHandleCaptor = ArgumentCaptor.forClass(ReceiptHandle.class);\n        when(this.messagingProcessor.forwardMessageToDeadLetterQueue(any(), receiptHandleCaptor.capture(), anyString(), anyString(), anyString()))\n            .thenReturn(CompletableFuture.completedFuture(RemotingCommand.createResponseCommand(ResponseCode.SUCCESS, \"\")));\n\n        String savedHandleStr = buildReceiptHandle(\"topic\", System.currentTimeMillis(),3000);\n        when(receiptHandleProcessor.removeReceiptHandle(any(), anyString(), anyString(), anyString()))\n            .thenReturn(new MessageReceiptHandle(\"group\", \"topic\", 0, savedHandleStr, \"msgId\", 0, 0));\n\n        ForwardMessageToDeadLetterQueueResponse response = this.forwardMessageToDLQActivity.forwardMessageToDeadLetterQueue(\n            createContext(),\n            ForwardMessageToDeadLetterQueueRequest.newBuilder()\n                .setTopic(Resource.newBuilder().setName(\"topic\").build())\n                .setGroup(Resource.newBuilder().setName(\"group\").build())\n                .setMessageId(MessageClientIDSetter.createUniqID())\n                .setReceiptHandle(buildReceiptHandle(\"topic\", System.currentTimeMillis(), 3000))\n                .build()\n        ).get();\n\n        assertEquals(Code.OK, response.getStatus().getCode());\n        assertEquals(savedHandleStr, receiptHandleCaptor.getValue().getReceiptHandle());\n    }",
    "test_code_tgt": "@Test\n    public void testForwardMessageToDeadLetterQueueWhenHasMappingHandle() throws Throwable {\n        ArgumentCaptor<ReceiptHandle> receiptHandleCaptor = ArgumentCaptor.forClass(ReceiptHandle.class);\n        when(this.messagingProcessor.forwardMessageToDeadLetterQueue(any(), receiptHandleCaptor.capture(), anyString(), anyString(), anyString()))\n            .thenReturn(CompletableFuture.completedFuture(RemotingCommand.createResponseCommand(ResponseCode.SUCCESS, \"\")));\n\n        String savedHandleStr = buildReceiptHandle(\"topic\", System.currentTimeMillis(),3000);\n        when(receiptHandleProcessor.removeReceiptHandle(any(), any(), anyString(), anyString(), anyString()))\n            .thenReturn(new MessageReceiptHandle(\"group\", \"topic\", 0, savedHandleStr, \"msgId\", 0, 0));\n\n        ForwardMessageToDeadLetterQueueResponse response = this.forwardMessageToDLQActivity.forwardMessageToDeadLetterQueue(\n            createContext(),\n            ForwardMessageToDeadLetterQueueRequest.newBuilder()\n                .setTopic(Resource.newBuilder().setName(\"topic\").build())\n                .setGroup(Resource.newBuilder().setName(\"group\").build())\n                .setMessageId(MessageClientIDSetter.createUniqID())\n                .setReceiptHandle(buildReceiptHandle(\"topic\", System.currentTimeMillis(), 3000))\n                .build()\n        ).get();\n\n        assertEquals(Code.OK, response.getStatus().getCode());\n        assertEquals(savedHandleStr, receiptHandleCaptor.getValue().getReceiptHandle());\n    }",
    "prod_code_src": "public CompletableFuture<ForwardMessageToDeadLetterQueueResponse> forwardMessageToDeadLetterQueue(ProxyContext ctx,\n        ForwardMessageToDeadLetterQueueRequest request) {\n        CompletableFuture<ForwardMessageToDeadLetterQueueResponse> future = new CompletableFuture<>();\n        try {\n            validateTopicAndConsumerGroup(request.getTopic(), request.getGroup());\n\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n            String handleString = request.getReceiptHandle();\n            MessageReceiptHandle messageReceiptHandle = receiptHandleProcessor.removeReceiptHandle(grpcChannelManager.getChannel(ctx.getClientID()), group, request.getMessageId(), request.getReceiptHandle());\n            if (messageReceiptHandle != null) {\n                handleString = messageReceiptHandle.getReceiptHandleStr();\n            }\n            ReceiptHandle receiptHandle = ReceiptHandle.decode(handleString);\n\n            return this.messagingProcessor.forwardMessageToDeadLetterQueue(\n                ctx,\n                receiptHandle,\n                request.getMessageId(),\n                GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup()),\n                GrpcConverter.getInstance().wrapResourceWithNamespace(request.getTopic())\n            ).thenApply(result -> convertToForwardMessageToDeadLetterQueueResponse(ctx, result));\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }",
    "prod_code_tgt": "public CompletableFuture<ForwardMessageToDeadLetterQueueResponse> forwardMessageToDeadLetterQueue(ProxyContext ctx,\n        ForwardMessageToDeadLetterQueueRequest request) {\n        CompletableFuture<ForwardMessageToDeadLetterQueueResponse> future = new CompletableFuture<>();\n        try {\n            validateTopicAndConsumerGroup(request.getTopic(), request.getGroup());\n\n            String group = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup());\n            String handleString = request.getReceiptHandle();\n            MessageReceiptHandle messageReceiptHandle = receiptHandleProcessor.removeReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, request.getMessageId(), request.getReceiptHandle());\n            if (messageReceiptHandle != null) {\n                handleString = messageReceiptHandle.getReceiptHandleStr();\n            }\n            ReceiptHandle receiptHandle = ReceiptHandle.decode(handleString);\n\n            return this.messagingProcessor.forwardMessageToDeadLetterQueue(\n                ctx,\n                receiptHandle,\n                request.getMessageId(),\n                GrpcConverter.getInstance().wrapResourceWithNamespace(request.getGroup()),\n                GrpcConverter.getInstance().wrapResourceWithNamespace(request.getTopic())\n            ).thenApply(result -> convertToForwardMessageToDeadLetterQueueResponse(ctx, result));\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }",
    "test_id": 11,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2023-06-06 17:07:06+08:00",
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_test": "proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/route/RouteActivityTest.java#testQueryRoute",
    "changed_prod": "proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/route/RouteActivity.java#queryRoute",
    "test_code_src": "@Test\n    public void testQueryRoute() throws Throwable {\n        ConfigurationManager.getProxyConfig().setGrpcServerPort(8080);\n        ArgumentCaptor<List<org.apache.rocketmq.proxy.common.Address>> addressListCaptor = ArgumentCaptor.forClass(List.class);\n        when(this.messagingProcessor.getTopicRouteDataForProxy(any(), addressListCaptor.capture(), anyString()))\n            .thenReturn(createProxyTopicRouteData(2, 2, 6));\n        MetadataService metadataService = Mockito.mock(LocalMetadataService.class);\n        when(this.messagingProcessor.getMetadataService()).thenReturn(metadataService);\n        when(metadataService.getTopicMessageType(anyString())).thenReturn(TopicMessageType.NORMAL);\n\n        QueryRouteResponse response = this.routeActivity.queryRoute(\n            createContext(),\n            QueryRouteRequest.newBuilder()\n                .setEndpoints(grpcEndpoints)\n                .setTopic(Resource.newBuilder().setName(TOPIC).build())\n                .build()\n        ).get();\n\n        assertEquals(Code.OK, response.getStatus().getCode());\n        assertEquals(4, response.getMessageQueuesCount());\n        for (MessageQueue messageQueue : response.getMessageQueuesList()) {\n            assertEquals(grpcEndpoints, messageQueue.getBroker().getEndpoints());\n            assertEquals(Permission.READ_WRITE, messageQueue.getPermission());\n        }\n    }",
    "test_code_tgt": "@Test\n    public void testQueryRoute() throws Throwable {\n        ConfigurationManager.getProxyConfig().setGrpcServerPort(8080);\n        ArgumentCaptor<List<org.apache.rocketmq.proxy.common.Address>> addressListCaptor = ArgumentCaptor.forClass(List.class);\n        when(this.messagingProcessor.getTopicRouteDataForProxy(any(), addressListCaptor.capture(), anyString()))\n            .thenReturn(createProxyTopicRouteData(2, 2, 6));\n        MetadataService metadataService = Mockito.mock(LocalMetadataService.class);\n        when(this.messagingProcessor.getMetadataService()).thenReturn(metadataService);\n        when(metadataService.getTopicMessageType(any(), anyString())).thenReturn(TopicMessageType.NORMAL);\n\n        QueryRouteResponse response = this.routeActivity.queryRoute(\n            createContext(),\n            QueryRouteRequest.newBuilder()\n                .setEndpoints(grpcEndpoints)\n                .setTopic(Resource.newBuilder().setName(TOPIC).build())\n                .build()\n        ).get();\n\n        assertEquals(Code.OK, response.getStatus().getCode());\n        assertEquals(4, response.getMessageQueuesCount());\n        for (MessageQueue messageQueue : response.getMessageQueuesList()) {\n            assertEquals(grpcEndpoints, messageQueue.getBroker().getEndpoints());\n            assertEquals(Permission.READ_WRITE, messageQueue.getPermission());\n        }\n    }",
    "prod_code_src": "public CompletableFuture<QueryRouteResponse> queryRoute(ProxyContext ctx, QueryRouteRequest request) {\n        CompletableFuture<QueryRouteResponse> future = new CompletableFuture<>();\n        try {\n            validateTopic(request.getTopic());\n            List<org.apache.rocketmq.proxy.common.Address> addressList = this.convertToAddressList(request.getEndpoints());\n\n            String topicName = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getTopic());\n            ProxyTopicRouteData proxyTopicRouteData = this.messagingProcessor.getTopicRouteDataForProxy(\n                ctx, addressList, topicName);\n\n            List<MessageQueue> messageQueueList = new ArrayList<>();\n            Map<String, Map<Long, Broker>> brokerMap = buildBrokerMap(proxyTopicRouteData.getBrokerDatas());\n\n            TopicMessageType topicMessageType = messagingProcessor.getMetadataService().getTopicMessageType(topicName);\n            for (QueueData queueData : proxyTopicRouteData.getQueueDatas()) {\n                String brokerName = queueData.getBrokerName();\n                Map<Long, Broker> brokerIdMap = brokerMap.get(brokerName);\n                if (brokerIdMap == null) {\n                    break;\n                }\n                for (Broker broker : brokerIdMap.values()) {\n                    messageQueueList.addAll(this.genMessageQueueFromQueueData(queueData, request.getTopic(), topicMessageType, broker));\n                }\n            }\n\n            QueryRouteResponse response = QueryRouteResponse.newBuilder()\n                .setStatus(ResponseBuilder.getInstance().buildStatus(Code.OK, Code.OK.name()))\n                .addAllMessageQueues(messageQueueList)\n                .build();\n            future.complete(response);\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }",
    "prod_code_tgt": "public CompletableFuture<QueryRouteResponse> queryRoute(ProxyContext ctx, QueryRouteRequest request) {\n        CompletableFuture<QueryRouteResponse> future = new CompletableFuture<>();\n        try {\n            validateTopic(request.getTopic());\n            List<org.apache.rocketmq.proxy.common.Address> addressList = this.convertToAddressList(request.getEndpoints());\n\n            String topicName = GrpcConverter.getInstance().wrapResourceWithNamespace(request.getTopic());\n            ProxyTopicRouteData proxyTopicRouteData = this.messagingProcessor.getTopicRouteDataForProxy(\n                ctx, addressList, topicName);\n\n            List<MessageQueue> messageQueueList = new ArrayList<>();\n            Map<String, Map<Long, Broker>> brokerMap = buildBrokerMap(proxyTopicRouteData.getBrokerDatas());\n\n            TopicMessageType topicMessageType = messagingProcessor.getMetadataService().getTopicMessageType(ctx, topicName);\n            for (QueueData queueData : proxyTopicRouteData.getQueueDatas()) {\n                String brokerName = queueData.getBrokerName();\n                Map<Long, Broker> brokerIdMap = brokerMap.get(brokerName);\n                if (brokerIdMap == null) {\n                    break;\n                }\n                for (Broker broker : brokerIdMap.values()) {\n                    messageQueueList.addAll(this.genMessageQueueFromQueueData(queueData, request.getTopic(), topicMessageType, broker));\n                }\n            }\n\n            QueryRouteResponse response = QueryRouteResponse.newBuilder()\n                .setStatus(ResponseBuilder.getInstance().buildStatus(Code.OK, Code.OK.name()))\n                .addAllMessageQueues(messageQueueList)\n                .build();\n            future.complete(response);\n        } catch (Throwable t) {\n            future.completeExceptionally(t);\n        }\n        return future;\n    }",
    "test_id": 12,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2023-06-06 17:07:06+08:00",
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_test": "proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java#testSendRetryMessage",
    "changed_prod": "proxy/src/main/java/org/apache/rocketmq/proxy/processor/ProducerProcessor.java#fillTransactionData",
    "test_code_src": "@Test\n    public void testSendRetryMessage() throws Throwable {\n        String txId = MessageClientIDSetter.createUniqID();\n        String msgId = MessageClientIDSetter.createUniqID();\n        long commitLogOffset = 1000L;\n        long queueOffset = 100L;\n\n        SendResult sendResult = new SendResult();\n        sendResult.setSendStatus(SendStatus.SEND_OK);\n        sendResult.setTransactionId(txId);\n        sendResult.setMsgId(msgId);\n        sendResult.setOffsetMsgId(createOffsetMsgId(commitLogOffset));\n        sendResult.setQueueOffset(queueOffset);\n        ArgumentCaptor<SendMessageRequestHeader> requestHeaderArgumentCaptor = ArgumentCaptor.forClass(SendMessageRequestHeader.class);\n        when(this.messageService.sendMessage(any(), any(), any(), requestHeaderArgumentCaptor.capture(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(Lists.newArrayList(sendResult)));\n\n        List<Message> messageExtList = new ArrayList<>();\n        Message messageExt = createMessageExt(MixAll.getRetryTopic(CONSUMER_GROUP), \"tag\", 0, 0);\n        MessageAccessor.putProperty(messageExt, MessageConst.PROPERTY_RECONSUME_TIME, \"1\");\n        MessageAccessor.putProperty(messageExt, MessageConst.PROPERTY_MAX_RECONSUME_TIMES, \"16\");\n        messageExtList.add(messageExt);\n        AddressableMessageQueue messageQueue = mock(AddressableMessageQueue.class);\n        when(messageQueue.getBrokerName()).thenReturn(\"mockBroker\");\n\n        ArgumentCaptor<String> brokerNameCaptor = ArgumentCaptor.forClass(String.class);\n        ArgumentCaptor<Long> tranStateTableOffsetCaptor = ArgumentCaptor.forClass(Long.class);\n        ArgumentCaptor<Long> commitLogOffsetCaptor = ArgumentCaptor.forClass(Long.class);\n        when(transactionService.addTransactionDataByBrokerName(\n            brokerNameCaptor.capture(),\n            anyString(),\n            tranStateTableOffsetCaptor.capture(),\n            commitLogOffsetCaptor.capture(),\n            anyString(), any())).thenReturn(mock(TransactionData.class));\n\n        List<SendResult> sendResultList = this.producerProcessor.sendMessage(\n            createContext(),\n            (ctx, messageQueueView) -> messageQueue,\n            PRODUCER_GROUP,\n            MessageSysFlag.TRANSACTION_PREPARED_TYPE,\n            messageExtList,\n            3000\n        ).get();\n\n        assertNotNull(sendResultList);\n        assertEquals(\"mockBroker\", brokerNameCaptor.getValue());\n        assertEquals(queueOffset, tranStateTableOffsetCaptor.getValue().longValue());\n        assertEquals(commitLogOffset, commitLogOffsetCaptor.getValue().longValue());\n\n        SendMessageRequestHeader requestHeader = requestHeaderArgumentCaptor.getValue();\n        assertEquals(PRODUCER_GROUP, requestHeader.getProducerGroup());\n        assertEquals(MixAll.getRetryTopic(CONSUMER_GROUP), requestHeader.getTopic());\n        assertEquals(1, requestHeader.getReconsumeTimes().intValue());\n        assertEquals(16, requestHeader.getMaxReconsumeTimes().intValue());\n    }",
    "test_code_tgt": "@Test\n    public void testSendRetryMessage() throws Throwable {\n        String txId = MessageClientIDSetter.createUniqID();\n        String msgId = MessageClientIDSetter.createUniqID();\n        long commitLogOffset = 1000L;\n        long queueOffset = 100L;\n\n        SendResult sendResult = new SendResult();\n        sendResult.setSendStatus(SendStatus.SEND_OK);\n        sendResult.setTransactionId(txId);\n        sendResult.setMsgId(msgId);\n        sendResult.setOffsetMsgId(createOffsetMsgId(commitLogOffset));\n        sendResult.setQueueOffset(queueOffset);\n        ArgumentCaptor<SendMessageRequestHeader> requestHeaderArgumentCaptor = ArgumentCaptor.forClass(SendMessageRequestHeader.class);\n        when(this.messageService.sendMessage(any(), any(), any(), requestHeaderArgumentCaptor.capture(), anyLong()))\n            .thenReturn(CompletableFuture.completedFuture(Lists.newArrayList(sendResult)));\n\n        List<Message> messageExtList = new ArrayList<>();\n        Message messageExt = createMessageExt(MixAll.getRetryTopic(CONSUMER_GROUP), \"tag\", 0, 0);\n        MessageAccessor.putProperty(messageExt, MessageConst.PROPERTY_RECONSUME_TIME, \"1\");\n        MessageAccessor.putProperty(messageExt, MessageConst.PROPERTY_MAX_RECONSUME_TIMES, \"16\");\n        messageExtList.add(messageExt);\n        AddressableMessageQueue messageQueue = mock(AddressableMessageQueue.class);\n        when(messageQueue.getBrokerName()).thenReturn(\"mockBroker\");\n\n        ArgumentCaptor<String> brokerNameCaptor = ArgumentCaptor.forClass(String.class);\n        ArgumentCaptor<Long> tranStateTableOffsetCaptor = ArgumentCaptor.forClass(Long.class);\n        ArgumentCaptor<Long> commitLogOffsetCaptor = ArgumentCaptor.forClass(Long.class);\n        when(transactionService.addTransactionDataByBrokerName(\n            any(),\n            brokerNameCaptor.capture(),\n            anyString(),\n            tranStateTableOffsetCaptor.capture(),\n            commitLogOffsetCaptor.capture(),\n            anyString(), any())).thenReturn(mock(TransactionData.class));\n\n        List<SendResult> sendResultList = this.producerProcessor.sendMessage(\n            createContext(),\n            (ctx, messageQueueView) -> messageQueue,\n            PRODUCER_GROUP,\n            MessageSysFlag.TRANSACTION_PREPARED_TYPE,\n            messageExtList,\n            3000\n        ).get();\n\n        assertNotNull(sendResultList);\n        assertEquals(\"mockBroker\", brokerNameCaptor.getValue());\n        assertEquals(queueOffset, tranStateTableOffsetCaptor.getValue().longValue());\n        assertEquals(commitLogOffset, commitLogOffsetCaptor.getValue().longValue());\n\n        SendMessageRequestHeader requestHeader = requestHeaderArgumentCaptor.getValue();\n        assertEquals(PRODUCER_GROUP, requestHeader.getProducerGroup());\n        assertEquals(MixAll.getRetryTopic(CONSUMER_GROUP), requestHeader.getTopic());\n        assertEquals(1, requestHeader.getReconsumeTimes().intValue());\n        assertEquals(16, requestHeader.getMaxReconsumeTimes().intValue());\n    }",
    "prod_code_src": "protected void fillTransactionData(String producerGroup, AddressableMessageQueue messageQueue, SendResult sendResult, List<Message> messageList) {\n        try {\n            MessageId id;\n            if (sendResult.getOffsetMsgId() != null) {\n                id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());\n            } else {\n                id = MessageDecoder.decodeMessageId(sendResult.getMsgId());\n            }\n            this.serviceManager.getTransactionService().addTransactionDataByBrokerName(\n                messageQueue.getBrokerName(),\n                producerGroup,\n                sendResult.getQueueOffset(),\n                id.getOffset(),\n                sendResult.getTransactionId(),\n                messageList.get(0)\n            );\n        } catch (Throwable t) {\n            log.warn(\"fillTransactionData failed. messageQueue: {}, sendResult: {}\", messageQueue, sendResult, t);\n        }\n    }",
    "prod_code_tgt": "protected void fillTransactionData(ProxyContext ctx, String producerGroup, AddressableMessageQueue messageQueue, SendResult sendResult, List<Message> messageList) {\n        try {\n            MessageId id;\n            if (sendResult.getOffsetMsgId() != null) {\n                id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());\n            } else {\n                id = MessageDecoder.decodeMessageId(sendResult.getMsgId());\n            }\n            this.serviceManager.getTransactionService().addTransactionDataByBrokerName(\n                ctx,\n                messageQueue.getBrokerName(),\n                producerGroup,\n                sendResult.getQueueOffset(),\n                id.getOffset(),\n                sendResult.getTransactionId(),\n                messageList.get(0)\n            );\n        } catch (Throwable t) {\n            log.warn(\"fillTransactionData failed. messageQueue: {}, sendResult: {}\", messageQueue, sendResult, t);\n        }\n    }",
    "test_id": 17,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2023-06-06 17:07:06+08:00",
    "commit_src": "bee5077bcb77411f103aafb2220184f59db2c95e",
    "commit_tgt": "a325d144b24a1acdc92a5ac308865080532325d9",
    "changed_test": "proxy/src/test/java/org/apache/rocketmq/proxy/service/message/ClusterMessageServiceTest.java#testAckMessageByInvalidBrokerNameHandle",
    "changed_prod": "proxy/src/main/java/org/apache/rocketmq/proxy/service/message/ClusterMessageService.java#resolveBrokerAddr",
    "test_code_src": "@Test\n    public void testAckMessageByInvalidBrokerNameHandle() throws Exception {\n        when(topicRouteService.getBrokerAddr(anyString())).thenThrow(new MQClientException(ResponseCode.TOPIC_NOT_EXIST, \"\"));\n        try {\n            this.clusterMessageService.ackMessage(\n                ProxyContext.create(),\n                ReceiptHandle.builder()\n                    .startOffset(0L)\n                    .retrieveTime(System.currentTimeMillis())\n                    .invisibleTime(3000)\n                    .reviveQueueId(1)\n                    .topicType(ReceiptHandle.NORMAL_TOPIC)\n                    .brokerName(\"notExistBroker\")\n                    .queueId(0)\n                    .offset(123)\n                    .commitLogOffset(0L)\n                    .build(),\n                MessageClientIDSetter.createUniqID(),\n                new AckMessageRequestHeader(),\n                3000);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e instanceof ProxyException);\n            ProxyException proxyException = (ProxyException) e;\n            assertEquals(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, proxyException.getCode());\n        }\n    }",
    "test_code_tgt": "@Test\n    public void testAckMessageByInvalidBrokerNameHandle() throws Exception {\n        when(topicRouteService.getBrokerAddr(any(), anyString())).thenThrow(new MQClientException(ResponseCode.TOPIC_NOT_EXIST, \"\"));\n        try {\n            this.clusterMessageService.ackMessage(\n                ProxyContext.create(),\n                ReceiptHandle.builder()\n                    .startOffset(0L)\n                    .retrieveTime(System.currentTimeMillis())\n                    .invisibleTime(3000)\n                    .reviveQueueId(1)\n                    .topicType(ReceiptHandle.NORMAL_TOPIC)\n                    .brokerName(\"notExistBroker\")\n                    .queueId(0)\n                    .offset(123)\n                    .commitLogOffset(0L)\n                    .build(),\n                MessageClientIDSetter.createUniqID(),\n                new AckMessageRequestHeader(),\n                3000);\n            fail();\n        } catch (Exception e) {\n            assertTrue(e instanceof ProxyException);\n            ProxyException proxyException = (ProxyException) e;\n            assertEquals(ProxyExceptionCode.INVALID_RECEIPT_HANDLE, proxyException.getCode());\n        }\n    }",
    "prod_code_src": "protected String resolveBrokerAddr(String brokerName) {\n        try {\n            return this.topicRouteService.getBrokerAddr(brokerName);\n        } catch (Throwable t) {\n            throw new ProxyException(ProxyExceptionCode.INVALID_BROKER_NAME, \"cannot find broker \" + brokerName, t);\n        }\n    }",
    "prod_code_tgt": "protected String resolveBrokerAddr(ProxyContext ctx, String brokerName) {\n        try {\n            return this.topicRouteService.getBrokerAddr(ctx, brokerName);\n        } catch (Throwable t) {\n            throw new ProxyException(ProxyExceptionCode.INVALID_BROKER_NAME, \"cannot find broker \" + brokerName, t);\n        }\n    }",
    "test_id": 18,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  },
  {
    "repo_name": "apache/rocketmq",
    "commit_date": "2023-01-10 14:49:03+08:00",
    "commit_src": "0533816d42961d0ba0ea012a115261ea71dd30c4",
    "commit_tgt": "5894332918e7158d6ff4cc35b126a1b82a1f6b0c",
    "changed_test": "tools/src/test/java/org/apache/rocketmq/tools/command/broker/BrokerStatusSubCommandTest.java#testExecute",
    "changed_prod": "tools/src/main/java/org/apache/rocketmq/tools/command/broker/BrokerStatusSubCommand.java#buildCommandlineOptions",
    "test_code_src": "@Test\n    public void testExecute() throws SubCommandException {\n        BrokerStatusSubCommand cmd = new BrokerStatusSubCommand();\n        Options options = ServerUtil.buildCommandlineOptions(new Options());\n        String[] subargs = new String[] {\"-b 127.0.0.1:\" + listenPort(), \"-c default-cluster\"};\n        final CommandLine commandLine =\n            ServerUtil.parseCmdLine(\"mqadmin \" + cmd.commandName(), subargs,\n                cmd.buildCommandlineOptions(options), new DefaultParser());\n\n        cmd.execute(commandLine, options, null);\n    }",
    "test_code_tgt": "@Test\n    public void testExecute() throws SubCommandException {\n        BrokerStatusSubCommand cmd = new BrokerStatusSubCommand();\n        Options options = ServerUtil.buildCommandlineOptions(new Options());\n        String[] subargs = new String[] {\"-b 127.0.0.1:\" + listenPort()};\n        final CommandLine commandLine =\n            ServerUtil.parseCmdLine(\"mqadmin \" + cmd.commandName(), subargs,\n                cmd.buildCommandlineOptions(options), new DefaultParser());\n\n        cmd.execute(commandLine, options, null);\n    }",
    "prod_code_src": "@Override\n    public Options buildCommandlineOptions(Options options) {\n        Option opt = new Option(\"b\", \"brokerAddr\", true, \"Broker address\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"c\", \"clusterName\", true, \"which cluster\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        return options;\n    }",
    "prod_code_tgt": "@Override\n    public Options buildCommandlineOptions(Options options) {\n        OptionGroup optionGroup = new OptionGroup();\n        Option opt = new Option(\"b\", \"brokerAddr\", true, \"Broker address\");\n        optionGroup.addOption(opt);\n\n        opt = new Option(\"c\", \"clusterName\", true, \"which cluster\");\n        optionGroup.addOption(opt);\n\n        optionGroup.setRequired(true);\n        options.addOptionGroup(optionGroup);\n\n        return options;\n    }",
    "test_id": 19,
    "src_java_version": "1.8",
    "src_maven_version": "3.6.3",
    "tgt_java_version": "1.8",
    "tgt_maven_version": "3.6.3"
  }
]